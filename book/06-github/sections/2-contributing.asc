//////////////////////////
=== Contributing to a Project
//////////////////////////
=== プロジェクトへの貢献

//////////////////////////
Now that our account is set up, let's walk through some details that could be useful in helping you contribute to an existing project.
//////////////////////////
これでアカウントが用意できたので、次は、既存のプロジェクトへの貢献にあたって役立つであろうことを説明していきましょう。

//////////////////////////
==== Forking Projects
//////////////////////////
==== プロジェクトのフォーク

(((forking)))
//////////////////////////
If you want to contribute to an existing project to which you don’t have push access, you can ``fork'' the project.
What this means is that GitHub will make a copy of the project that is entirely yours; it lives in your user's namespace, and you can push to it.
//////////////////////////
既存のプロジェクトに貢献したいけれども、そのリポジトリにプッシュする権限がないという場合は、プロジェクトを「フォーク」できます。
「フォーク」するとは、GitHub があなた専用にそのプロジェクトのコピーを作るということです。あなた自身の名前空間に置かれるので、そこには自分でプッシュできます。

[NOTE]
//////////////////////////
====
Historically, the term ``fork'' has been somewhat negative in context, meaning that someone took an open source project in a different direction, sometimes creating a competing project and splitting the contributors.
In GitHub, a ``fork'' is simply the same project in your own namespace, allowing you to make changes to a project publicly as a way to contribute in a more open manner.
====
//////////////////////////
====
歴史的に、この「フォーク」という用語はあまり好ましくない意味で使われてきました。
何かのオープンソースプロジェクトの方針を気に入らない人が、別の道を歩み出すこと
（そして時には、競合するプロジェクトを作って、貢献者を引き抜いてしまうこと）を指していたのです。
GitHub における「フォーク」とは、単にあなたの配下に作られるコピー以外の何者でもありません。
自分自身による変更を公開の場でそのプロジェクトに適用でき、よりオープンなやりかたでプロジェクトに貢献できるようにするための手段なのです。
====

//////////////////////////
This way, projects don’t have to worry about adding users as collaborators to give them push access.
People can fork a project, push to it, and contribute their changes back to the original repository by creating what's called a Pull Request, which we'll cover next.
This opens up a discussion thread with code review, and the owner and the contributor can then communicate about the change until the owner is happy with it, at which point the owner can merge it in.
//////////////////////////
この方式なら、協力してくれる人たちにいちいちプッシュアクセス権を付与していく必要はありません。
それぞれがプロジェクトをフォークして、そこにプッシュして、その変更を元のリポジトリに提供したければ、いわゆる「プルリクエスト」を作ればいいのです。
プルリクエストについては、後ほど説明します。
プルリクエストを作ると、そこにコードレビューのスレッドが立ち上がります。
プロジェクトのオーナーとプルリクエストの作者は、そこで変更についての議論を重ねて、
オーナーが納得した時点で、それをマージすることができます。

//////////////////////////
To fork a project, visit the project page and click the ``Fork'' button at the top-right of the page.
//////////////////////////
プロジェクトをフォークするには、プロジェクトのページに行って、ページ右上にある``Fork''ボタンを押します。

//////////////////////////
.The ``Fork'' button.
image::images/forkbutton.png[The ``Fork'' button.]
//////////////////////////
.``Fork'' ボタン
image::images/forkbutton.png[``Fork'' ボタン]

//////////////////////////
After a few seconds, you'll be taken to your new project page, with your own writeable copy of the code.
//////////////////////////
数秒後、新しいプロジェクトのページに自動的に移動します。これは、あなた自身が書き込み可能なコピーです。

[[ch06-github_flow]]
//////////////////////////
==== The GitHub Flow
//////////////////////////
==== GitHub Flow

(((GitHub, Flow)))
//////////////////////////
GitHub is designed around a particular collaboration workflow, centered on Pull Requests.
This flow works whether you're collaborating with a tightly-knit team in a single shared repository, or a globally-distributed company or network of strangers contributing to a project through dozens of forks.
It is centered on the <<ch03-git-branching#r_topic_branch>> workflow covered in <<ch03-git-branching#ch03-git-branching>>.
//////////////////////////
GitHub は、プルリクエストを中心としたコラボレーションのワークフローを想定して作られています。
ひとつのリポジトリを共有する密接に連携したチームでの作業であっても、世界中に広がる企業や個人が関わるプロジェクトで何十ものフォークがあるプロジェクトであっても、
このワークフローはうまく機能します。
その中心になるのが、<<ch03-git-branching#ch03-git-branching>> でとりあげた <<ch03-git-branching#r_topic_branch>> のワークフローです。

//////////////////////////
Here's how it generally works:
//////////////////////////
全体的な流れは、以下のようになります。

//////////////////////////
1. Create a topic branch from `master`.
2. Make some commits to improve the project.
3. Push this branch to your GitHub project.
4. Open a Pull Request on GitHub.
5. Discuss, and optionally continue committing.
6. The project owner merges or closes the Pull Request.
//////////////////////////
1. `master` からトピックブランチを作る。
2. そこに、プロジェクトの改良につながるコミットをする。
3. このブランチを、自分の GitHub プロジェクトにプッシュする。
4. GitHub 上でプルリクエストを作る。
5. 議論を重ね、必要ならさらにコミットをする。
6. プロジェクトのオーナーは、プルリクエストをマージする（あるいは、マージせずに閉じる）。

//////////////////////////
This is basically the Integration Manager workflow covered in <<ch05-distributed-git#r_integration_manager>>, but instead of using email to communicate and review changes, teams use GitHub's web based tools.
//////////////////////////
これは基本的に、<<ch05-distributed-git#r_integration_manager>> でとりあげる、統合マネージャー型のワークフローです。
しかし、変更についてのやりとりやレビューをメールで行う代わりに、ここでは GitHub のウェブベースのツールを使います。

//////////////////////////
Let's walk through an example of proposing a change to an open source project hosted on GitHub using this flow.
//////////////////////////
GitHub で公開しているオープンソースのプロジェクトに対して、このフローを使って変更を提案する例を見ていきましょう。

//////////////////////////
===== Creating a Pull Request
//////////////////////////
===== プルリクエストの作成

//////////////////////////
Tony is looking for code to run on his Arduino programmable microcontroller and has found a great program file on GitHub at https://github.com/schacon/blink[].
//////////////////////////
自分のArduino上で実行するコードを探していたトニーは、GitHub 上にすばらしいプログラムがあることを発見しました。
それが https://github.com/schacon/blink[] です。

//////////////////////////
.The project we want to contribute to.
image::images/blink-01-start.png[The project we want to contribute to.]
//////////////////////////
.貢献したいプロジェクト
image::images/blink-01-start.png[貢献したいプロジェクト]

//////////////////////////
The only problem is that the blinking rate is too fast, we think it's much nicer to wait 3 seconds instead of 1 in between each state change.
So let's improve the program and submit it back to the project as a proposed change.
//////////////////////////
ただ、ひとつ問題がありました。点滅の間隔が速すぎるのです。1 秒おきに状態を切り替えるのではなく、3 秒くらいは間を置きたいものです。
さて、このプログラムを改良して、その変更を提案してみましょう。

//////////////////////////
First, we click the 'Fork' button as mentioned earlier to get our own copy of the project.
Our user name here is ``tonychacon'' so our copy of this project is at `https://github.com/tonychacon/blink` and that's where we can edit it.
We will clone it locally, create a topic branch, make the code change and finally push that change back up to GitHub.
//////////////////////////
まずは、先ほど説明した 'Fork' ボタンをクリックして、このプロジェクトのコピーを手に入れます。
この例で使うユーザー名は ``tonychacon'' とします。つまり、できあがったコピーは `https://github.com/tonychacon/blink` となり、ここからはこのプロジェクトを変更していきます。
これをローカルにクローンして、トピックブランチを作り、コードを変更して、その変更を GitHub にプッシュしましょう。

[source,console]
----
$ git clone https://github.com/tonychacon/blink <1>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <2>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino <3>

$ git diff --word-diff <4>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'three seconds is better' <5>
[slow-blink 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <6>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -> slow-blink
----

//////////////////////////
<1> Clone our fork of the project locally
<2> Create a descriptive topic branch
<3> Make our change to the code
<4> Check that the change is good
<5> Commit our change to the topic branch
<6> Push our new topic branch back up to our GitHub fork
//////////////////////////
<1> フォークしたプロジェクトを、ローカルにクローンする
<2> わかりやすい名前のトピックブランチを作る
<3> コードを変更する
<4> 問題はなさそうだ
<5> この変更をトピックブランチにコミットする
<6> 新しいトピックブランチを、GitHub 上のフォークに書き戻す

//////////////////////////
Now if we go back to our fork on GitHub, we can see that GitHub noticed that we pushed a new topic branch up and present us with a big green button to check out our changes and open a Pull Request to the original project.
//////////////////////////
この状態で GitHub 上のフォークに戻ると、GitHub 上に新しいトピックブランチがプッシュされたことを伝えてくれます。
また、大きな緑色のボタンを使えば、変更点を確認したり、元のプロジェクトへのプルリクエストを送ったりできます。

//////////////////////////
You can alternatively go to the ``Branches'' page at `https://github.com/<user>/<project>/branches` to locate your branch and open a new Pull Request from there.
//////////////////////////
あるいは、`https://github.com/<user>/<project>/branches` にある ``Branches'' ページから自分のトピックブランチに移動して、そこからプルリクエストを送ることもできます。

//////////////////////////
.Pull Request button
image::images/blink-02-pr.png[Pull Request button]
//////////////////////////
.プルリクエストのボタン
image::images/blink-02-pr.png[プルリクエストのボタン]

(((GitHub, pull requests)))
//////////////////////////
If we click that green button, we'll see a screen that asks us to give our Pull Request a title and description.
It is almost always worthwhile to put some effort into this, since a good description helps the owner of the original project determine what you were trying to do, whether your proposed changes are correct, and whether accepting the changes would improve the original project.
//////////////////////////
この緑のボタンをクリックすると、プルリクエストのタイトルと説明を入力する画面に遷移します。
ちゃんと時間をかけて説明を書きましょう。損はしないはずです。プルリクエストを受ける側のプロジェクトオーナーからすれば、説明文がよければあなたの意図が汲み取りやすくなるからです。そうすれば、オーナーはプルリクエストの内容を正確に評価できますし、それを取り込むことがプロジェクトにとってプラスかどうかを判断できるでしょう。


//////////////////////////
We also see a list of the commits in our topic branch that are ``ahead'' of the `master` branch (in this case, just the one) and a unified diff of all the changes that will be made should this branch get merged by the project owner.
//////////////////////////
この画面では、トピックブランチ内のコミットのうち、`master`よりも先行しているコミットの一覧 (今回の場合はひとつだけ) も確認できます。
また、このブランチをオーナーがマージしたときに適用される変更の、unified形式の差分も表示されます。

//////////////////////////
.Pull Request creation page
image::images/blink-03-pull-request-open.png[Pull Request creation]
//////////////////////////
.プルリクエストの作成ページ
image::images/blink-03-pull-request-open.png[プルリクエストの作成]

//////////////////////////
When you hit the 'Create pull request' button on this screen, the owner of the project you forked will get a notification that someone is suggesting a change and will link to a page that has all of this information on it.
//////////////////////////
この画面で 'Create pull request' ボタンを押すと、フォーク元のプロジェクトのオーナーに、
誰かが変更を提案しているという通知が届きます。この通知には、変更に関するすべての情報が記載されたページへのリンクが含まれています。

[NOTE]
//////////////////////////
====
Though Pull Requests are used commonly for public projects like this when the contributor has a complete change ready to be made, it's also often used in internal projects _at the beginning_ of the development cycle. Since you can keep pushing to the topic branch even *after* the Pull Request is opened, it's often opened early and used as a way to iterate on work as a team within a context, rather than opened at the very end of the process.
====
//////////////////////////
====
一般にプルリクエストは、こういった公開プロジェクトに対する変更を、その準備が整った時点で提案するために作るものです。
しかし、内部的なプロジェクトの開発サイクルにおいて、 _開発を始めるタイミングで_ プルリクエストを作ることもよくあります。
プルリクエストを作った*後でも*、そのトピックブランチへのプッシュを続けることができます。
最後の最後にプルリクエストを行うのではなく、早い時点でプルリクエストを作っておけば、
その後の作業状況をチーム内で共有できます。
====

//////////////////////////
===== Iterating on a Pull Request
//////////////////////////
===== プルリクエストの繰り返し

//////////////////////////
At this point, the project owner can look at the suggested change and merge it, reject it or comment on it. Let's say that he likes the idea, but would prefer a slightly longer time for the light to be off than on.
//////////////////////////
これで、元のプロジェクトのオーナーは、変更の提案を見られるようになりました。それをマージしたり、却下したり、コメントしたりすることができます。
ここでは、オーナーが変更提案を気に入ったものの、ライトが消えている時間を点灯している時間よりも少しだけ長くしたほうがいいと感じたことにしましょう。

//////////////////////////
Where this conversation may take place over email in the workflows presented in <<ch05-distributed-git#ch05-distributed-git>>, on GitHub this happens online. The project owner can review the unified diff and leave a comment by clicking on any of the lines.
//////////////////////////
<<ch05-distributed-git#ch05-distributed-git>> のワークフローなら、この手のやりとりはメールで行うところですが、GitHub の場合はこれをオンラインで行います。
プロジェクトのオーナーはunfied diffをレビューして、コメントを残します。コメントしたい行をクリックすれば、コメントを残せます。

//////////////////////////
.Comment on a specific line of code in a Pull Request
image::images/blink-04-pr-comment.png[PR line comment]
//////////////////////////
.プルリクエストのコードの特定の行へのコメント
image::images/blink-04-pr-comment.png[PRの行コメント]

//////////////////////////
Once the maintainer makes this comment, the person who opened the Pull Request (and indeed, anyone else watching the repository) will get a notification. We'll go over customizing this later, but if he had email notifications turned on, Tony would get an email like this:
//////////////////////////
メンテナがコメントを入れると、プルリクエストの作者 (そして、そのリポジトリをウォッチしているすべての人たち) に、通知が届きます。
通知をカスタマイズする方法については後述しますが、メールでの通知を受け取るように設定している場合は、以下のようなメールも届きます。

[[r_email_notification]]
//////////////////////////
.Comments sent as email notifications
image::images/blink-04-email.png[Email notification]
//////////////////////////
.通知メールで送られたコメント
image::images/blink-04-email.png[メールでの通知]

//////////////////////////
Anyone can also leave general comments on the Pull Request. In <<r_pr_discussion>> we can see an example of the project owner both commenting on a line of code and then leaving a general comment in the discussion section. You can see that the code comments are brought into the conversation as well.
//////////////////////////
オーナーだけでなく誰でも、プルリクエスト全体に対するコメントができます。
<<r_pr_discussion>> では、プロジェクトのオーナーがコードの特定の行についてコメントしたうえで、さらにプルリクエスト全体に関するコメントも残しています。
また、コードへのコメントが、一連の会話に組み込まれていることにもお気づきでしょう。

[[r_pr_discussion]]
//////////////////////////
.Pull Request discussion page
image::images/blink-05-general-comment.png[PR discussion page]
//////////////////////////
.プルリクエストのディスカッションページ
image::images/blink-05-general-comment.png[PRのディスカッションページ]

//////////////////////////
Now the contributor can see what they need to do in order to get their change accepted.
Luckily this is also a very simple thing to do.
Where over email you may have to re-roll your series and resubmit it to the mailing list, with GitHub you simply commit to the topic branch again and push, which will automatically update the Pull Request.
In <<r_pr_final>> you can also see that the old code comment has been collapsed in the updated Pull Request, since it was made on a line that has since been changed.
//////////////////////////
プルリクエストの作者は、自分の変更を受け入れてもらうために何が必要なのかがわかりました。
幸運にも、そんなに手間のかかることではありません。
メールでのやりとりの場合は、一連の作業をやり直した上でもう一度メーリングリストに投稿する必要がありますが、
GitHub なら、単にトピックブランチにコミットしてそれをプッシュするだけで済みます。
また、<<r_pr_final>> にあるように、更新されたプルリクエストでは変更前のコードへのコメント表示が省略されています。追加されたコミットによって変更されたコードへのコメントだからです。

//////////////////////////
Adding commits to an existing Pull Request doesn't trigger a notification, so once Tony has pushed his corrections he decides to leave a comment to inform the project owner that he made the requested change.
//////////////////////////
なお、既存のプルリクエストにコミットを追加しても、通知は送られません。そこで、修正をプッシュしたトニーは、修正が終わったことをコメントでプロジェクトオーナーに伝えることにしました。

[[r_pr_final]]
//////////////////////////
.Pull Request final
image::images/blink-06-final.png[PR final]
//////////////////////////
.プルリクエストの最終形
image::images/blink-06-final.png[PRの最終形]

//////////////////////////
An interesting thing to notice is that if you click on the ``Files Changed'' tab on this Pull Request, you'll get the ``unified'' diff -- that is, the total aggregate difference that would be introduced to your main branch if this topic branch was merged in. In `git diff` terms, it basically automatically shows you `git diff master...<branch>` for the branch this Pull Request is based on. See <<ch05-distributed-git#r_what_is_introduced>> for more about this type of diff.
//////////////////////////
このプルリクエストのページで ``Files Changed'' タブをクリックすると、``unified'' 形式の diff を確認できます。
つまり、このトピックブランチをマージしたときにどんな変更が施されるのかを、まとめて確認できるのです。
`git diff` の用語に直すと、このタブを開いたときに表示される内容は、プルリクエストの対象になっているブランチ上で
`git diff master...<branch>` を実行した結果になります。
この形式の diff についての詳細は、<<ch05-distributed-git#r_what_is_introduced>> を参照ください。

//////////////////////////
The other thing you'll notice is that GitHub checks to see if the Pull Request merges cleanly and provides a button to do the merge for you on the server. This button only shows up if you have write access to the repository and a trivial merge is possible. If you click it GitHub will perform a ``non-fast-forward'' merge, meaning that even if the merge *could* be a fast-forward, it will still create a merge commit.
//////////////////////////
もうひとつお気づきのことがあることでしょう。
GitHub は、このプルリクエストが問題なくマージできることを確認したうえで、サーバー上でマージを実行するためのボタンを表示します。
このボタンが表示されるのは、あなたがこのリポジトリへの書き込みアクセス権限を持っていて、かつ問題なくマージ可能な場合だけです。
このボタンをクリックすると、GitHub は ``non-fast-forward'' なマージを行います。
つまり、仮に fast-forward 可能なマージであったとしても、明示的にマージコミットを作ります。

//////////////////////////
If you would prefer, you can simply pull the branch down and merge it locally. If you merge this branch into the `master` branch and push it to GitHub, the Pull Request will automatically be closed.
//////////////////////////
お望みなら、このブランチを取得した上で、ローカルでマージすることもできます。
このブランチを `master` にマージしてから GitHub にプッシュすると、このプルリクエストは自動的に閉じられます。

//////////////////////////
This is the basic workflow that most GitHub projects use. Topic branches are created, Pull Requests are opened on them, a discussion ensues, possibly more work is done on the branch and eventually the request is either closed or merged.
//////////////////////////
これが、大半の GitHub プロジェクトが使っている基本的なワークフローです。
トピックブランチを作り、そこからプルリクエストを作って、議論を重ね、必要に応じてさらに作業を重ねて、最終的にそのリクエストをマージするか、あるいはマージせずに終了します。

[NOTE]
//////////////////////////
.Not Only Forks
====
It's important to note that you can also open a Pull Request between two branches in the same repository. If you're working on a feature with someone and you both have write access to the project, you can push a topic branch to the repository and open a Pull Request on it to the `master` branch of that same project to initiate the code review and discussion process. No forking necessary.
====
//////////////////////////
.フォークしなくてもかまわない
====
同じリポジトリのふたつのブランチ間でのプルリクエストもできるということを知っておきましょう。
誰かと一緒に何らかのフィーチャーの作業をしていて、両方ともそのプロジェクトへの書き込み権限を持っている場合なら、
トピックブランチをそのリポジトリにプッシュした上で、同じプロジェクトの `master` ブランチへのプルリクエストを作ることができます。
そこで、コードのレビューや議論を進めればいいでしょう。
このときに、わざわざフォークする必要はありません。
====

//////////////////////////
==== Advanced Pull Requests
//////////////////////////
==== プルリクエストの応用テクニック

//////////////////////////
Now that we've covered the basics of contributing to a project on GitHub, let's cover a few interesting tips and tricks about Pull Requests so you can be more effective in using them.
//////////////////////////
GitHub のプロジェクトに貢献する際の基本がわかったところで、
プルリクエストに関するちょっとしたヒントやテクニックを紹介しましょう。これらを使えば、プルリクエストをさらに活用できるでしょう。

//////////////////////////
===== Pull Requests as Patches
//////////////////////////
===== パッチとしてのプルリクエスト

//////////////////////////
It's important to understand that many projects don't really think of Pull Requests as queues of perfect patches that should apply cleanly in order, as most mailing list-based projects think of patch series contributions. Most GitHub projects think about Pull Request branches as iterative conversations around a proposed change, culminating in a unified diff that is applied by merging.
//////////////////////////
実際のところ、多くのプロジェクトは、プルリクエストを完璧なパッチ群である (つまり、きちんと順序どおりに適用しなければいけない) とは考えていません。
これは、メーリングリストベースで運営するプロジェクトで一般的な考えかたとは異なります。
GitHub のプロジェクトでは、プルリクエストのブランチを変更提案に関する議論の場と捕らえていることが多く、
最終的にできあがった unified diff をマージするのだと考えています。

//////////////////////////
This is an important distinction, because generally the change is suggested before the code is thought to be perfect, which is far more rare with mailing list based patch series contributions. This enables an earlier conversation with the maintainers so that arriving at the proper solution is more of a community effort. When code is proposed with a Pull Request and the maintainers or community suggest a change, the patch series is generally not re-rolled, but instead the difference is pushed as a new commit to the branch, moving the conversation forward with the context of the previous work intact.
//////////////////////////
この違いを認識しておくことが大切です。一般に、変更を提案するのは、コードが完璧に仕上がる前の段階です。
一方、メーリングリストベースの運営では、まだできあがってもいないパッチを投稿することなど、まずないでしょう。
未完成の段階で変更を提案することで、メンテナとの議論を早めに始めることができます。
コミュニティの協力で、より適切なソリューションにたどり着けるようになるでしょう。
プルリクエストで提案したコードに対してメンテナやコミュニティから変更の提案があったときに、
パッチをゼロから作り直す必要はありません。
差分だけを、新たなコミットとしてプッシュすればいいのです。
その後の議論は、これまでの経緯を踏まえた上で進みます。

//////////////////////////
For instance, if you go back and look again at <<r_pr_final>>, you'll notice that the contributor did not rebase his commit and send another Pull Request. Instead they added new commits and pushed them to the existing branch. This way if you go back and look at this Pull Request in the future, you can easily find all of the context of why decisions were made. Pushing the ``Merge'' button on the site purposefully creates a merge commit that references the Pull Request so that it's easy to go back and research the original conversation if necessary.
//////////////////////////
<<r_pr_final>> をもう一度見てみましょう。プルリクエストの作者は、自分のコミットをリベースして新たなプルリクエストを作ったわけではありません。
単に、新しいコミットを追加して、それを既存のブランチにプッシュしただけです。
そのおかげで、今後このプルリクエストのページを見直すことがあったときにも、最終的な決定に至るまでの経緯を簡単に確認できるのです。
``Merge'' ボタンを押したときに、本来不要な場面でも意図的にマージコミットを作っているのは、
後からそのプルリクエストを参照しやすいようにするためです。
必要に応じて、それまでの流れをすぐに調べることができます。

//////////////////////////
===== Keeping up with Upstream
//////////////////////////
===== 上流への追従

//////////////////////////
If your Pull Request becomes out of date or otherwise doesn't merge cleanly, you will want to fix it so the maintainer can easily merge it. GitHub will test this for you and let you know at the bottom of every Pull Request if the merge is trivial or not.
//////////////////////////
プルリクエストを作った後で元のプロジェクトに変更が加わったなどの理由で、プルリクエストがそのままではマージできなくなることがあります。
そんな場合は、そのプルリクエストを修正して、メンテナがマージしやすいようにしておきたいことでしょう。
GitHub は、そのままでマージできるかどうかをチェックして、すべてのプルリクエストのページの最下部に結果を表示します。

[[r_pr_fail]]
//////////////////////////
.Pull Request does not merge cleanly
image::images/pr-01-fail.png[PR merge failure]
//////////////////////////
.そのままではマージできないプルリクエスト
image::images/pr-01-fail.png[マージできないPR]

//////////////////////////
If you see something like <<r_pr_fail>>, you'll want to fix your branch so that it turns green and the maintainer doesn't have to do extra work.
//////////////////////////
<<r_pr_fail>> のようになっていたら、自分のブランチを修正して、この表示がグリーンになるようにしたいところです。
そうすれば、メンテナに余計な手間をかけさせずに済みます。

//////////////////////////
You have two main options in order to do this. You can either rebase your branch on top of whatever the target branch is (normally the `master` branch of the repository you forked), or you can merge the target branch into your branch.
//////////////////////////
グリーンにするための主な選択肢は、二種類あります。
ひとつは、自分のブランチを、プルリクエストの対象ブランチ (普通は、フォーク元のリポジトリの `master`) の先端にリベースすること。
もうひとつは、その対象ブランチを自分のブランチにマージすることです。

//////////////////////////
Most developers on GitHub will choose to do the latter, for the same reasons we just went over in the previous section. What matters is the history and the final merge, so rebasing isn't getting you much other than a slightly cleaner history and in return is *far* more difficult and error prone.
//////////////////////////
GitHub 上の開発者の多くは、後者を選んでいるようです。その理由は、先述したとおりです。
重要なのは、そこにいたるまでの歴史と、最終的にマージしたという事実だと考えているのでしょう。
リベースをすると、歴史がすっきりするという以外の利点はありません。そして、リベースはマージに比べて *ずっと* 難しいし、間違いを起こしやすいものです。

//////////////////////////
If you want to merge in the target branch to make your Pull Request mergeable, you would add the original repository as a new remote, fetch from it, merge the main branch of that repository into your topic branch, fix any issues and finally push it back up to the same branch you opened the Pull Request on.
//////////////////////////
対象ブランチをマージして、自分のプルリクエストをそのまま取り込んでもらえるようにする手順は、次のとおりです。
まず、オリジナルのリポジトリを新しいリモートとして追加して、それをフェッチします。
そして、そのリポジトリのメインブランチを自分のトピックブランチにマージします。
何か問題があれば修正し、その結果をプルリクエストと同じブランチにプッシュします。

//////////////////////////
For example, let's say that in the ``tonychacon'' example we were using before, the original author made a change that would create a conflict in the Pull Request. Let's go through those steps.
//////////////////////////
先ほどの ``tonychacon'' の例に戻りましょう。プルリクエストを出した後にオリジナルの作者がリポジトリに変更を加えたため、
プルリクエストがそのままでは取り込めなくなってしまいました。そんな場合の手順は、以下のとおりです。

[source,console]
----
$ git remote add upstream https://github.com/schacon/blink <1>

$ git fetch upstream <2>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -> upstream/master

$ git merge upstream/master <3>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <4>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <5>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -> slow-blink
----

//////////////////////////
<1> Add the original repository as a remote named ``upstream''
<2> Fetch the newest work from that remote
<3> Merge the main branch into your topic branch
<4> Fix the conflict that occurred
<5> Push back up to the same topic branch
//////////////////////////
<1> オリジナルのリポジトリを ``upstream'' という名前のリモートとして追加する
<2> そのリモートの、最新の状態をフェッチする
<3> メインブランチを、自分のトピックブランチにマージする
<4> 衝突を解決する
<5> 同じトピックブランチに、再びプッシュする

//////////////////////////
Once you do that, the Pull Request will be automatically updated and re-checked to see if it merges cleanly.
//////////////////////////
これでプルリクエストが自動的に更新されて、マージ可能かどうかが再びチェックされます。

[[r_pr_merge_fix]]
//////////////////////////
.Pull Request now merges cleanly
image::images/pr-02-merge-fix.png[PR fixed]
//////////////////////////
.そのままマージできるようになったプルリクエスト
image::images/pr-02-merge-fix.png[修正後のPR]

//////////////////////////
One of the great things about Git is that you can do that continuously. If you have a very long-running project, you can easily merge from the target branch over and over again and only have to deal with conflicts that have arisen since the last time that you merged, making the process very manageable.
//////////////////////////
Git のすばらしいところのひとつが、これらの作業を継続的に行えるということです。
長期にわたるプロジェクトでも、対象ブランチからのマージを何度でも繰り返せるので、前回のマージ以降に発生した衝突さえ気をつけていれば、混乱なく作業を続けられます。

//////////////////////////
If you absolutely wish to rebase the branch to clean it up, you can certainly do so, but it is highly encouraged to not force push over the branch that the Pull Request is already opened on. If other people have pulled it down and done more work on it, you run into all of the issues outlined in <<ch03-git-branching#r_rebase_peril>>. Instead, push the rebased branch to a new branch on GitHub and open a brand new Pull Request referencing the old one, then close the original.
//////////////////////////
ブランチをリベースしてすっきりさせたい場合は、そうしてもかまいません。
しかし、既に作成済みのプルリクエストに対して、それを強制的にプッシュするのは避けたほうがいいでしょう。
もし他の人がそれを手元に取得して何かの作業を進めると、<<ch03-git-branching#r_rebase_peril>> で説明したような問題が発生します。
リベースした場合は、それを GitHub 上で新しいブランチにして、新しいプルリクエストを作るようにしましょう。
新しいプルリクエストから元のプルリクエストを参照して、そして元のプルリクエストは閉じてしまいます。

//////////////////////////
===== References
//////////////////////////
===== 参照

//////////////////////////
Your next question may be ``How do I reference the old Pull Request?''. It turns out there are many, many ways to reference other things almost anywhere you can write in GitHub.
//////////////////////////
…と言われて気になるのは、「元のプルリクエストをどうやって参照すればいいの？」ということでしょう。
GitHub 上で他のものを参照するにはいろんな方法があって、GitHub 上で何かを書ける場所ならほぼどこでも他のものを参照できます。

//////////////////////////
Let's start with how to cross-reference another Pull Request or an Issue. All Pull Requests and Issues are assigned numbers and they are unique within the project. For example, you can't have Pull Request #3 _and_ Issue #3. If you want to reference any Pull Request or Issue from any other one, you can simply put `#<num>` in any comment or description. You can also be more specific if the Issue or Pull request lives somewhere else; write `username#<num>` if you're referring to an Issue or Pull Request in a fork of the repository you're in, or `username/repo#<num>` to reference something in another repository.
//////////////////////////
まずは、別のプルリクエストあるいは Issue を相互参照する方法から紹介します。
プルリクエストや Issue には番号が振られていて、この番号はプロジェクト内で一意になっています。
つまり、たとえばプルリクエスト#3とIssue #3が _両方とも_ 存在することはありえないのです。
他のプルリクエストや Issue を参照したい場合は、コメントや説明文の中で単に `#<num>` と書くだけでかまいません。
あるいは、もう少し細かく、誰か他の人が作った Issue やプルリクエストを指定することもできます。
`username#<num>` と書けば、今いるリポジトリの別のフォーク上での Issue やプルリクエストを参照できるし、
`username/repo#<num>` と書けば、別のリポジトリ上のものも参照できます。

//////////////////////////
Let's look at an example. Say we rebased the branch in the previous example, created a new pull request for it, and now we want to reference the old pull request from the new one. We also want to reference an issue in the fork of the repository and an issue in a completely different project. We can fill out the description just like <<r_pr_references>>.
//////////////////////////
実例を見てみましょう。
先ほど説明したとおり、リベースをした上で新しいプルリクエストを作ったものとします。新しいプルリクエストから、古いプルリクエストを参照したいところです。
また、そのリポジトリのフォーク上にある Issue や、まったく別のプロジェクトにある Issue も参照するつもりです。
説明文は、<<r_pr_references>> のようになります。

[[r_pr_references]]
//////////////////////////
.Cross references in a Pull Request.
image::images/mentions-01-syntax.png[PR references]
//////////////////////////
.プルリクエスト内での相互参照
image::images/mentions-01-syntax.png[PRの参照]

//////////////////////////
When we submit this pull request, we'll see all of that rendered like <<r_pr_references_render>>.
//////////////////////////
このプルリクエストを投稿すると、画面上では <<r_pr_references_render>> のような表示になります。

[[r_pr_references_render]]
//////////////////////////
.Cross references rendered in a Pull Request.
image::images/mentions-02-render.png[PR references rendered]
//////////////////////////
.プルリクエスト内での相互参照のレンダリング
image::images/mentions-02-render.png[PR内での参照のレンダリング]

//////////////////////////
Notice that the full GitHub URL we put in there was shortened to just the information needed.
//////////////////////////
GitHub の完全な URL を入力したところも、画面上では短縮されて、必要な情報だけが見えていることがわかるでしょう。

//////////////////////////
Now if Tony goes back and closes out the original Pull Request, we can see that by mentioning it in the new one, GitHub has automatically created a trackback event in the Pull Request timeline. This means that anyone who visits this Pull Request and sees that it is closed can easily link back to the one that superseded it. The link will look something like <<r_pr_closed>>.
//////////////////////////
トニーが元のプルリクエストを閉じると、そのことが新しいプルリクエストのほうにも表示されることがわかります。
GitHub が、プルリクエストのタイムラインに自動的にトラックバックを送ったのです。
これで、古いプルリクエストを見にきたすべての人は、そのリクエストの後継となる新しいプルリクエストにたどり着けるようになるのです。
リンクは、<<r_pr_closed>> のように表示されます。

[[r_pr_closed]]
//////////////////////////
.Cross references rendered in a Pull Request.
image::images/mentions-03-closed.png[PR closed]
//////////////////////////
.プルリクエスト内での相互参照のレンダリング
image::images/mentions-03-closed.png[閉じられたPR]

//////////////////////////
In addition to issue numbers, you can also reference a specific commit by SHA-1. You have to specify a full 40 character SHA-1, but if GitHub sees that in a comment, it will link directly to the commit. Again, you can reference commits in forks or other repositories in the same way you did with issues.
//////////////////////////
issue の番号だけでなく、SHA-1 を示して特定のコミットを参照することもできます。
SHA-1 を指定する際には 40 文字ぶんすべてを示す必要がありますが、コメントの中に SHA-1 を発見すると、GitHub はそれを当該コミットへリンクしてくれます。
他のフォークやその他のリポジトリのコミットを参照する場合の方法は、issue の場合と同じです。

//////////////////////////
==== Markdown
//////////////////////////
==== Markdown

//////////////////////////
Linking to other Issues is just the beginning of interesting things you can do with almost any text box on GitHub. In  Issue and Pull Request descriptions, comments, code comments and more, you can use what is called ``GitHub Flavored Markdown''. Markdown is like writing in plain text but which is rendered richly.
//////////////////////////
他の Issue へのリンクは、GitHub のテキストボックスでできるさまざまなことのうちの、ほんの始まりに過ぎません。
Issue やプルリクエストの説明、それに対するコメント、コードに対するコメントなどなどでは、いわゆる ``GitHub Flavored Markdown'' を使うことができます。
Markdown はプレーンテキストと似ていますが、よりリッチなレンダリングを行います。

//////////////////////////
See <<r_example_markdown>> for an example of how comments or text can be written and then rendered using Markdown.
//////////////////////////
コメントや説明文を、Markdown を使って書いた例を <<r_example_markdown>> に示します。

[[r_example_markdown]]
//////////////////////////
.An example of Markdown as written and as rendered.
image::images/markdown-01-example.png[Example Markdown]
//////////////////////////
.Markdown での記述例と、そのレンダリング結果
image::images/markdown-01-example.png[Markdown の例]

//////////////////////////
===== GitHub Flavored Markdown
//////////////////////////
===== GitHub Flavored Markdown

//////////////////////////
The GitHub flavor of Markdown adds more things you can do beyond the basic Markdown syntax. These can all be really useful when creating useful Pull Request or Issue comments or descriptions.
//////////////////////////
GitHub Flavored Markdownは、基本的なMarkdownの文法に、GitHub 流の味付けをしたものです。
プルリクエストや Issue を作ったり、それにコメントしたりするときに、役立つことでしょう。

//////////////////////////
====== Task Lists
//////////////////////////
====== タスクリスト

//////////////////////////
The first really useful GitHub specific Markdown feature, especially for use in Pull Requests, is the Task List. A task list is a list of checkboxes of things you want to get done. Putting them into an Issue or Pull Request normally indicates things that you want to get done before you consider the item complete.
//////////////////////////
GitHub 流の Markdown で追加された便利な機能の中で、最初に紹介する機能が、タスクリストです。これは、プルリクエストで特に便利です。
タスクリストとは、チェックボックス付きの、やることリストです。
これを Issue やプルリクエストで使うと、完了させるまでに何を済ませなければいけないのかを表せます。

//////////////////////////
You can create a task list like this:
//////////////////////////
タスクリストの作りかたは、以下のとおりです。

[source,text]
----
- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code
----

//////////////////////////
If we include this in the description of our Pull Request or Issue, we'll see it rendered like <<r_task_lists>>
//////////////////////////
プルリクエストや Issue の説明文にこのように書いておくと、<<r_task_lists>> のような表示になります。

[[r_task_lists]]
//////////////////////////
.Task lists rendered in a Markdown comment.
image::images/markdown-02-tasks.png[Example Task List]
//////////////////////////
.Markdown でのコメント内に表示されたタスクリスト
image::images/markdown-02-tasks.png[タスクリストの例]

//////////////////////////
This is often used in Pull Requests to indicate what all you would like to get done on the branch before the Pull Request will be ready to merge. The really cool part is that you can simply click the checkboxes to update the comment -- you don't have to edit the Markdown directly to check tasks off.
//////////////////////////
これはたとえば、プルリクエストに対して、「これだけのことを済ませればマージの準備が整う」ということを示すために使うことがあります。
この機能のすばらしいところは、単にチェックボックスをクリックするだけで、コメントが更新できるということです。
タスクが完了したときに、わざわざ Markdown を直接編集する必要はありません。

//////////////////////////
What's more, GitHub will look for task lists in your Issues and Pull Requests and show them as metadata on the pages that list them out. For example, if you have a Pull Request with tasks and you look at the overview page of all Pull Requests, you can see how far done it is. This helps people break down Pull Requests into subtasks and helps other people track the progress of the branch. You can see an example of this in <<r_task_list_progress>>.
//////////////////////////
さらに、GitHub は、Issue やプルリクエストの中にあるタスクリストを見つけて、そのメタデータを一覧ページにも表示してくれます。
たとえば、あるプルリクエストの中でタスクを作ったときに、プルリクエストの一覧ページを見ると、タスクがどの程度完了しているのかを確認できるのです。
これは、プルリクエストをサブタスクに切り分けたり、他のひとたちがそのブランチの進捗を追いかけたりする際にも役立ちます。
この機能の実例を <<r_task_list_progress>> に示します。

[[r_task_list_progress]]
//////////////////////////
.Task list summary in the Pull Request list.
image::images/markdown-03-task-summary.png[Example Task List]
//////////////////////////
.プルリクエスト一覧における、タスク一覧の概要表示
image::images/markdown-03-task-summary.png[タスクリストの例]

//////////////////////////
These are incredibly useful when you open a Pull Request early and use it to track your progress through the implementation of the feature.
//////////////////////////
この機能は、
トピックブランチを作ったばかりのときにプルリクエストを出して、その後の実装の進捗をプルリクエスト上で追いかけていくような場合に、とても便利です。

//////////////////////////
====== Code Snippets
//////////////////////////
====== コードスニペット

//////////////////////////
You can also add code snippets to comments. This is especially useful if you want to present something that you _could_ try to do before actually implementing it as a commit on your branch. This is also often used to add example code of what is not working or what this Pull Request could implement.
//////////////////////////
コメントに、コードスニペットを追加することもできます。
これは、これから _やろうとしている_ ことを、実際に実装する前に表明したりするときに便利です。
また、うまく動かないサンプルコードや、このプルリクエストで実装できることを説明するサンプルコードなどを示すときにも使われます。

//////////////////////////
To add a snippet of code you have to ``fence'' it in backticks.
//////////////////////////
コードスニペットを追加するには、バッククォートで「囲む」必要があります。

[source,text]
----
```java
for(int i=0 ; i < 5 ; i++)
{
   System.out.println("i is : " + i);
}
```
----

//////////////////////////
If you add a language name like we did there with 'java', GitHub will also try to syntax highlight the snippet. In the case of the above example, it would end up rendering like <<r_md_code>>.
//////////////////////////
このサンプルでの 'java' のように言語名を追加すると、GitHub はスニペットのシンタックスハイライトを行います。
このサンプルは、最終的に <<r_md_code>> のような表示になります。

[[r_md_code]]
//////////////////////////
.Rendered fenced code example.
image::images/markdown-04-fenced-code.png[Rendered fenced code]
//////////////////////////
.サンプルコードをレンダリングした結果
image::images/markdown-04-fenced-code.png[レンダリングされたコード]

//////////////////////////
====== Quoting
//////////////////////////
====== 引用

//////////////////////////
If you're responding to a small part of a long comment, you can selectively quote out of the other comment by preceding the lines with the `>` character. In fact, this is so common and so useful that there is a keyboard shortcut for it. If you highlight text in a comment that you want to directly reply to and hit the `r` key, it will quote that text in the comment box for you.
//////////////////////////
長いコメントの一部に返信するときは、その部分を引用することができます。引用するには、各行の先頭に `>` を付け加えます。
これはとても便利で、よく使われるものなので、キーボードショートカットも用意されています。
コメントの中で返信したい部分を選択して `r` キーを押すと、選択した部分を引用した、新しいコメント入力欄が現れます。

//////////////////////////
The quotes look something like this:
//////////////////////////
引用は、このような感じになります。

[source,text]
----
> Whether 'tis Nobler in the mind to suffer
> The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?
----

//////////////////////////
Once rendered, the comment will look like <<r_md_quote>>.
//////////////////////////
このコメントが、画面上では <<r_md_quote>> のようにレンダリングされます。

[[r_md_quote]]
//////////////////////////
.Rendered quoting example.
image::images/markdown-05-quote.png[Rendered quoting]
//////////////////////////
.引用のレンダリングの例
image::images/markdown-05-quote.png[引用のレンダリング]

//////////////////////////
====== Emoji
//////////////////////////
====== 絵文字

//////////////////////////
Finally, you can also use emoji in your comments. This is actually used quite extensively in comments you see on many GitHub Issues and Pull Requests. There is even an emoji helper in GitHub. If you are typing a comment and you start with a `:` character, an autocompleter will help you find what you're looking for.
//////////////////////////
最後に紹介するのが絵文字です。コメントの中で、絵文字を使えます。
実際に、GitHub の Issue やプルリクエストの多くで、絵文字が使われています。
GitHub には、絵文字の入力支援機能もあるのです。
コメントの記入中に `:` を入力すると、オートコンプリート機能が立ち上がって、絵文字を探すのを手伝ってくれます。

[[r_md_emoji_auto]]
//////////////////////////
.Emoji autocompleter in action.
image::images/markdown-06-emoji-complete.png[Emoji autocompleter]
//////////////////////////
.絵文字のオートコンプリートの例
image::images/markdown-06-emoji-complete.png[絵文字のオートコンプリート]

//////////////////////////
Emojis take the form of `:<name>:` anywhere in the comment. For instance, you could write something like this:
//////////////////////////
絵文字は `:<name>:` 形式で表し、コメント内のどこでも使えます。
たとえば、このように書いたとしましょう。

[source,text]
----
I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:
----

//////////////////////////
When rendered, it would look something like <<r_md_emoji>>.
//////////////////////////
これをレンダリングした結果は、<<r_md_emoji>> のようになります。

[[r_md_emoji]]
//////////////////////////
.Heavy emoji commenting.
image::images/markdown-07-emoji.png[Emoji]
//////////////////////////
.絵文字だらけのコメント
image::images/markdown-07-emoji.png[絵文字]

//////////////////////////
Not that this is incredibly useful, but it does add an element of fun and emotion to a medium that is otherwise hard to convey emotion in.
//////////////////////////
めちゃめちゃ便利というほどのものではありませんが、
楽しさや熱意を伝える手段としては他の追随を許さないものでしょう。


[NOTE]
//////////////////////////
====
There are actually quite a number of web services that make use of emoji characters these days. A great cheat sheet to reference to find emoji that expresses what you want to say can be found at:

http://www.emoji-cheat-sheet.com
====
//////////////////////////
====
最近は、絵文字を使えるウェブサービスも多くなってきました。
自分の言いたいことをうまく伝えられる絵文字を見つけるための、チートシートも公開されています。

http://www.emoji-cheat-sheet.com
====

//////////////////////////
====== Images
//////////////////////////
====== 画像

//////////////////////////
This isn't technically GitHub Flavored Markdown, but it is incredibly useful. In addition to adding Markdown image links to comments, which can be difficult to find and embed URLs for, GitHub allows you to drag and drop images into text areas to embed them.
//////////////////////////
厳密に言うと GitHub Flavored Markdown とは関係ありませんが、これはとても便利な機能です。
Markdown でのコメントに画像のリンクを追加するのは、画像を探したり URL を埋め込んだりと面倒くさいものです。
しかし GitHub では、テキストエリアに画像をドラッグ＆ドロップするだけで、それを埋め込めるのです。

[[r_md_drag]]
//////////////////////////
.Drag and drop images to upload them and auto-embed them.
image::images/markdown-08-drag-drop.png[Drag and drop images]
//////////////////////////
.ドラッグ＆ドロップで画像をアップロードして、自動的に埋め込む
image::images/markdown-08-drag-drop.png[画像のドラッグ＆ドロップ]

//////////////////////////
If you look back at <<r_pr_references>>, you can see a small ``Parsed as Markdown'' hint above the text area. Clicking on that will give you a full cheat sheet of everything you can do with Markdown on GitHub.
//////////////////////////
<<r_pr_references>> に戻ると、テキストエリアの上に小さく ``Parsed as Markdown'' とヒントが書かれていることがわかります。
これをクリックすると、GitHub 上での Markdown でできるすべてのことをまとめた、チートシートを見ることができます。

