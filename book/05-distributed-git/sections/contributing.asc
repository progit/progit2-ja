[[_contributing_project]]
//////////////////////////
=== Contributing to a Project
//////////////////////////
=== プロジェクトへの貢献

(((contributing)))
//////////////////////////
The main difficulty with describing how to contribute to a project is that there are a huge number of variations on how it's done.
Because Git is very flexible, people can and do work together in many ways, and it's problematic to describe how you should contribute – every project is a bit different.
Some of the variables involved are active contributor count, chosen workflow, your commit access, and possibly the external contribution method.
//////////////////////////
どうやってプロジェクトに貢献するか、というのは非常に説明しづらい内容です。というのも、ほんとうにいろいろなパターンがあるからです。
Git は柔軟なシステムなので、いろいろな方法で共同作業をすることができます。そのせいもあり、どのプロジェクトをとってみても微妙に他とは異なる方式を使っているのです。
違いが出てくる原因としては、アクティブな貢献者の数やプロジェクトで使用しているワークフロー、あなたのコミット権、そして外部からの貢献を受け入れる際の方式などがあります。

//////////////////////////
The first variable is active contributor count – how many users are actively contributing code to this project, and how often?
In many instances, you'll have two or three developers with a few commits a day, or possibly less for somewhat dormant projects.
For larger companies or projects, the number of developers could be in the thousands, with hundreds or thousands of commits coming in each day.
This is important because with more and more developers, you run into more issues with making sure your code applies cleanly or can be easily merged.
Changes you submit may be rendered obsolete or severely broken by work that is merged in while you were working or while your changes were waiting to be approved or applied.
How can you keep your code consistently up to date and your commits valid?
//////////////////////////
最初の要素はアクティブな貢献者の数です。そのプロジェクトに対してアクティブにコードを提供している開発者はどれくらいいるのか、そして彼らはどれくらいの頻度で提供しているのか。
よくあるのは、数名の開発者が一日数回のコミットを行うというものです。休眠状態のプロジェクトなら、もう少し頻度が低くなるでしょう。
企業やプロジェクトの規模が大きくなると、開発者の数が数千人になることもあります。数百から下手したら千を超えるようなコミットが毎日やってきます。
開発者の数が増えれば増えるほど、あなたのコードをきちんと適用したり他のコードをマージしたりするのが難しくなります。
あなたが手元で作業をしている間に他の変更が入って、手元で変更した内容が無意味になってしまったりあるいは他の変更を壊してしまう羽目になったり。そのせいで、手元の変更を適用してもらうための待ち時間が発生したり。
手元のコードを常に最新の状態にし、正しいコミットを作るにはどうしたらいいのでしょうか。

//////////////////////////
The next variable is the workflow in use for the project.
Is it centralized, with each developer having equal write access to the main codeline?
Does the project have a maintainer or integration manager who checks all the patches?
Are all the patches peer-reviewed and approved?
Are you involved in that process?
Is a lieutenant system in place, and do you have to submit your work to them first?
//////////////////////////
次に考えるのは、プロジェクトが採用しているワークフローです。
中央管理型で、すべての開発者がコードに対して同等の書き込みアクセス権を持っている状態?
特定のメンテナーや統合マネージャーがすべてのパッチをチェックしている?
パッチを適用する前にピアレビューをしている?
あなたはパッチをチェックしたりピアレビューに参加したりしている人?
副官型のワークフローを使っており、まず彼らにコードを渡さなければならない?

//////////////////////////
The next issue is your commit access.
The workflow required in order to contribute to a project is much different if you have write access to the project than if you don't.
If you don't have write access, how does the project prefer to accept contributed work?
Does it even have a policy?
How much work are you contributing at a time?
How often do you contribute?
//////////////////////////
次の問題は、あなたのコミット権です。
あなたがプロジェクトへの書き込みアクセス権限を持っている場合は、プロジェクトに貢献するための作業の流れが変わってきます。
書き込み権限がない場合、そのプロジェクトではどのような形式での貢献を推奨していますか?
何かポリシーのようなものはありますか?
一度にどれくらいの作業を貢献することになりますか?
また、どれくらいの頻度で貢献することになりますか?

//////////////////////////
All these questions can affect how you contribute effectively to a project and what workflows are preferred or available to you.
We'll cover aspects of each of these in a series of use cases, moving from simple to more complex; you should be able to construct the specific workflows you need in practice from these examples.
//////////////////////////
これらの点を考慮して、あなたがどんな流れでどのようにプロジェクトに貢献していくのかが決まります。
単純なものから複雑なものまで、実際の例を見ながら考えていきましょう。これらの例を参考に、あなたなりのワークフローを見つけてください。

[[_commit_guidelines]]
//////////////////////////
==== Commit Guidelines
//////////////////////////
==== コミットの指針

//////////////////////////
Before we start looking at the specific use cases, here's a quick note about commit messages.
Having a good guideline for creating commits and sticking to it makes working with Git and collaborating with others a lot easier.
The Git project provides a document that lays out a number of good tips for creating commits from which to submit patches – you can read it in the Git source code in the `Documentation/SubmittingPatches` file.
//////////////////////////
個々の例を見る前に、コミットメッセージについてのちょっとした注意点をお話しておきましょう。
コミットに関する指針をきちんと定めてそれを守るようにすると、Git での共同作業がよりうまく進むようになります。
Git プロジェクトでは、パッチの投稿用のコミットを作成するときのヒントをまとめたドキュメントを用意しています。Git のソースの中にある `Documentation/SubmittingPatches` をごらんください。

(((git commands, diff, check)))
//////////////////////////
First, you don't want to submit any whitespace errors.
Git provides an easy way to check for this – before you commit, run `git diff --check`, which identifies possible whitespace errors and lists them for you.
//////////////////////////
まず、余計な空白文字を含めてしまわないように注意が必要です。
Git には、余計な空白文字をチェックするための簡単な仕組みがあります。コミットする前に `git diff --check` を実行してみましょう。おそらく意図したものではないと思われる空白文字を探し、それを教えてくれます。

//////////////////////////
.Output of `git diff --check`.
image::images/git-diff-check.png[Output of `git diff --check`.]
//////////////////////////
.`git diff --check` 実行結果
image::images/git-diff-check.png[`git diff --check` 実行結果]

//////////////////////////
If you run that command before committing, you can tell if you're about to commit whitespace issues that may annoy other developers.
//////////////////////////
コミットの前にこのコマンドを実行すれば、余計な空白文字をコミットしてしまって他の開発者に嫌がられることもなくなるでしょう。

//////////////////////////
Next, try to make each commit a logically separate changeset.
If you can, try to make your changes digestible – don't code for a whole weekend on five different issues and then submit them all as one massive commit on Monday.
Even if you don't commit during the weekend, use the staging area on Monday to split your work into at least one commit per issue, with a useful message per commit.
If some of the changes modify the same file, try to use `git add --patch` to partially stage files (covered in detail in <<_interactive_staging>>).
The project snapshot at the tip of the branch is identical whether you do one commit or five, as long as all the changes are added at some point, so try to make things easier on your fellow developers when they have to review your changes.
This approach also makes it easier to pull out or revert one of the changesets if you need to later.
<<_rewriting_history>> describes a number of useful Git tricks for rewriting history and interactively staging files – use these tools to help craft a clean and understandable history before sending the work to someone else.
//////////////////////////
次に、コミットの単位が論理的に独立した変更となるようにしましょう。
つまり、個々の変更内容を把握しやすくするということです。週末に五つの問題点を修正した大規模な変更を、月曜日にまとめてコミットするなどということは避けましょう。
仮に週末の間にコミットできなかったとしても、ステージングエリアを活用して月曜日にコミット内容を調整することができます。修正した問題ごとにコミットを分割し、それぞれに適切なコメントをつければいいのです。
もし別々の問題の修正で同じファイルを変更しているのなら、`git add --patch` を使ってその一部だけをステージすることもできます (詳しくは <<_interactive_staging>> で説明します)。
すべての変更を同時に追加しさえすれば、一度にコミットしようが五つのコミットに分割しようがブランチの先端は同じ状態になります。あとから変更内容をレビューする他のメンバーのことも考えて、できるだけレビューしやすい状態でコミットするようにしましょう。
こうしておけば、あとからその変更の一部だけを取り消したりするのにも便利です。
<<_rewriting_history>> では、Git を使って歴史を書き換えたり対話的にファイルをステージしたりする方法を説明します。作業内容を誰かに送る前にその方法を使えば、きれいでわかりやすい歴史を作り上げることができます。

//////////////////////////
The last thing to keep in mind is the commit message.
Getting in the habit of creating quality commit messages makes using and collaborating with Git a lot easier.
As a general rule, your messages should start with a single line that's no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation.
The Git project requires that the more detailed explanation include your motivation for the change and contrast its implementation with previous behavior – this is a good guideline to follow.
It's also a good idea to use the imperative present tense in these messages.
In other words, use commands.
Instead of ``I added tests for'' or ``Adding tests for,'' use ``Add tests for.''
Here is a template originally written by Tim Pope:
//////////////////////////
最後に注意しておきたいのが、コミットメッセージです。
よりよいコミットメッセージを書く習慣を身に着けておくと、Git を使った共同作業をより簡単に行えるようになります。
一般的な規則として、メッセージの最初には変更の概要を一行 (50 文字以内) にまとめた説明をつけるようにします。その後に空行をひとつ置いてからより詳しい説明を続けます。
Git プロジェクトでは、その変更の動機やこれまでの実装との違いなどのできるだけ詳しい説明をつけることを推奨しています。参考にするとよいでしょう。
また、メッセージでは命令形、現在形を使うようにしています。
つまり ``私は○○のテストを追加しました (I added tests for)'' とか ``○○のテストを追加します (Adding tests for,)'' ではなく ``○○のテストを追加 (Add tests for.)'' 形式にするということです。
Tim Pope が書いたテンプレート (の日本語訳) を以下に示します。

[source,text]
//////////////////////////
-----
Short (50 chars or less) summary of changes

More detailed explanatory text, if necessary.  Wrap it to
about 72 characters or so.  In some contexts, the first
line is treated as the subject of an email and the rest of
the text as the body.  The blank line separating the
summary from the body is critical (unless you omit the body
entirely); tools like rebase can get confused if you run
the two together.

Further paragraphs come after blank lines.

  - Bullet points are okay, too

  - Typically a hyphen or asterisk is used for the bullet,
    preceded by a single space, with blank lines in
    between, but conventions vary here
-----
//////////////////////////
-----
短い (50 文字以下での) 変更内容のまとめ

必要に応じた、より詳細な説明。72文字程度で折り返します。最初の
行がメールの件名、残りの部分がメールの本文だと考えてもよいでしょ
う。最初の行と詳細な説明の間には、必ず空行を入れなければなりま
せん (詳細説明がまったくない場合は空行は不要です)。空行がないと、
rebase などがうまく動作しません。

空行を置いて、さらに段落を続けることもできます。

  - 箇条書きも可能

  - 箇条書きの記号としては、主にハイフンやアスタリスクを使います。
    箇条書き記号の前にはひとつ空白を入れ、各項目の間には空行を入
    れます。しかし、これ以外の流儀もいろいろあります。
-----

//////////////////////////
If all your commit messages look like this, things will be a lot easier for you and the developers you work with.
The Git project has well-formatted commit messages – try running `git log --no-merges` there to see what a nicely formatted project-commit history looks like.
//////////////////////////
すべてのコミットメッセージがこのようになっていれば、他の開発者との作業が非常に進めやすくなるでしょう。
Git プロジェクトでは、このようにきれいに整形されたコミットメッセージを使っています。`git log --no-merges` を実行すれば、きれいに整形されたプロジェクトの歴史がどのように見えるかがわかります。

//////////////////////////
In the following examples, and throughout most of this book, for the sake of brevity this book doesn't have nicely-formatted messages like this; instead, we use the `-m` option to `git commit`.
Do as we say, not as we do.
//////////////////////////
これ以降の例を含めて本書では、説明を簡潔にするためにこのような整形を省略します。そのかわりに `git commit` の `-m` オプションを使います。
本書でのこのやり方をまねするのではなく、ここで説明した方式を使いましょう。

[[_private_team]]
//////////////////////////
==== Private Small Team
//////////////////////////
==== 非公開な小規模のチーム

(((contributing, private small team)))
//////////////////////////
The simplest setup you're likely to encounter is a private project with one or two other developers.
``Private,'' in this context, means closed-source – not accessible to the outside world.
You and the other developers all have push access to the repository.
//////////////////////////
実際に遭遇するであろう環境のうち最も小規模なのは、非公開のプロジェクトで開発者が数名といったものです。
ここでいう「非公開」とは、クローズドソースであるということ。つまり、チームのメンバー以外は見られないということです。
チーム内のメンバーは全員、リポジトリへのプッシュ権限を持っています。

//////////////////////////
In this environment, you can follow a workflow similar to what you might do when using Subversion or another centralized system.
You still get the advantages of things like offline committing and vastly simpler branching and merging, but the workflow can be very similar; the main difference is that merges happen client-side rather than on the server at commit time.
Let's see what it might look like when two developers start to work together with a shared repository.
The first developer, John, clones the repository, makes a change, and commits locally.
(The protocol messages have been replaced with `...` in these examples to shorten them somewhat.)
//////////////////////////
こういった環境では、今まで Subversion やその他の中央管理型システムを使っていたときとほぼ同じワークフローで作業を進めることができます。
オフラインでコミットできたりブランチやマージが楽だったりといった Git ならではの利点はいかせますが、作業の流れ自体は今までとほぼ同じです。最大の違いは、マージが (コミット時にサーバー側で行われるのではなく) クライアント側で行われるということです。
二人の開発者が共有リポジトリで開発を始めるときにどうなるかを見ていきましょう。
最初の開発者 John が、リポジトリをクローンして変更を加え、それをローカルでコミットします (これ以降のメッセージでは、プロトコル関連のメッセージを `...` で省略しています)。

[source,console]
//////////////////////////
-----
# John's Machine
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'removed invalid default value'
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
-----
//////////////////////////
-----
# John のマシン
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'removed invalid default value'
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

//////////////////////////
The second developer, Jessica, does the same thing – clones the repository and commits a change:
//////////////////////////
もう一人の開発者 Jessica も同様に、リポジトリをクローンして変更をコミットしました。

[source,console]
//////////////////////////
-----
# Jessica's Machine
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
-----
//////////////////////////
-----
# Jessica のマシン
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

//////////////////////////
Now, Jessica pushes her work up to the server:
//////////////////////////
Jessica が作業内容をサーバーにプッシュします。

[source,console]
//////////////////////////
-----
# Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
-----
//////////////////////////
-----
# Jessica のマシン
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
-----

//////////////////////////
John tries to push his change up, too:
//////////////////////////
John も同様にプッシュしようとしました。

[source,console]
//////////////////////////
-----
# John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
-----
//////////////////////////
-----
# John のマシン
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
-----

//////////////////////////
John isn't allowed to push because Jessica has pushed in the meantime.
This is especially important to understand if you're used to Subversion, because you'll notice that the two developers didn't edit the same file.
Although Subversion automatically does such a merge on the server if different files are edited, in Git you must merge the commits locally.
John has to fetch Jessica's changes and merge them in before he will be allowed to push:
//////////////////////////
John はプッシュできませんでした。Jessica が先にプッシュを済ませていたからです。
Subversion になじみのある人には特に注目してほしいのですが、ここで John と Jessica が編集していたのは別々のファイルです。
Subversion ならこのような場合はサーバー側で自動的にマージを行いますが、Git の場合はローカルでマージしなければなりません。
John は、まず Jessica の変更内容を取得してマージしてからでないと、自分の変更をプッシュできないのです。

[source,console]
-----
$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -> origin/master
-----

//////////////////////////
At this point, John's local repository looks something like this:
//////////////////////////
この時点で、John のローカルリポジトリはこのようになっています。

//////////////////////////
.John's divergent history.
image::images/small-team-1.png[John's divergent history.]
//////////////////////////
.John の分岐した歴史
image::images/small-team-1.png[John の分岐した歴史]

//////////////////////////
John has a reference to the changes Jessica pushed up, but he has to merge them into his own work before he is allowed to push:
//////////////////////////
John の手元に Jessica がプッシュした内容が届きましたが、さらにそれを彼自身の作業にマージしてからでないとプッシュできません。

[source,console]
-----
$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

//////////////////////////
The merge goes smoothly – John's commit history now looks like this:
//////////////////////////
マージがうまくいきました。John のコミット履歴は次のようになります。

//////////////////////////
.John's repository after merging `origin/master`.
image::images/small-team-2.png[John's repository after merging `origin/master`.]
//////////////////////////
.`origin/master` をマージしたあとの John のリポジトリ
image::images/small-team-2.png[`origin/master` をマージしたあとの John のリポジトリ]

//////////////////////////
Now, John can test his code to make sure it still works properly, and then he can push his new merged work up to the server:
//////////////////////////
自分のコードが正しく動作することを確認した John は、変更内容をサーバーにプッシュします。

[source,console]
-----
$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -> master
-----

//////////////////////////
Finally, John's commit history looks like this:
//////////////////////////
最終的に、John のコミット履歴は以下のようになりました。

//////////////////////////
.John's history after pushing to the `origin` server.
image::images/small-team-3.png[John's history after pushing to the `origin` server.]
//////////////////////////
.origin サーバーにプッシュした後の John の履歴
image::images/small-team-3.png[origin サーバーにプッシュした後の John の履歴]

//////////////////////////
In the meantime, Jessica has been working on a topic branch.
She's created a topic branch called `issue54` and done three commits on that branch.
She hasn't fetched John's changes yet, so her commit history looks like this:
//////////////////////////
一方そのころ、Jessica はトピックブランチで作業を進めていました。
`issue54` というトピックブランチを作成した彼女は、そこで 3 回コミットをしました。
彼女はまだ John の変更を取得していません。したがって、彼女のコミット履歴はこのような状態です。

//////////////////////////
.Jessica's topic branch.
image::images/small-team-4.png[Jessica's topic branch.]
//////////////////////////
.Jessica のコミット履歴
image::images/small-team-4.png[Jessica のコミット履歴]

//////////////////////////
Jessica wants to sync up with John, so she fetches:
//////////////////////////
Jessica は John の作業を取り込もうとしました。

[source,console]
//////////////////////////
-----
# Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -> origin/master
-----
//////////////////////////
-----
# Jessica のマシン
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -> origin/master
-----

//////////////////////////
That pulls down the work John has pushed up in the meantime.
Jessica's history now looks like this:
//////////////////////////
これで、さきほど John がプッシュした内容が取り込まれました。Jessica の履歴は次のようになります。

//////////////////////////
.Jessica's history after fetching John's changes.
image::images/small-team-5.png[Jessica's history after fetching John's changes.]
//////////////////////////
.John の変更を取り込んだ後の Jessica の履歴
image::images/small-team-5.png[John の変更を取り込んだ後の Jessica の履歴]

//////////////////////////
Jessica thinks her topic branch is ready, but she wants to know what she has to merge into her work so that she can push.
She runs `git log` to find out:
//////////////////////////
Jessica のトピックブランチ上での作業が完了しました。そこで、自分の作業をプッシュする前に何をマージしなければならないのかを確認するため、
彼女は `git log` コマンドを実行しました。

[source,console]
-----
$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 16:01:27 2009 -0700

   removed invalid default value
-----

//////////////////////////
The `issue54..origin/master` syntax is a log filter that asks Git to only show the list of commits that are on the latter branch (in this case `origin/master`) that are not on the first branch (in this case `issue54`). We'll go over this syntax in detail in <<_commit_ranges>>.
//////////////////////////
`issue54..origin/master` はログのフィルター記法です。このように書くと、後者のブランチ（この例では `origin/master` ）には含まれるが前者のブランチ（この例では `issue54` ）には含まれないコミットのログだけを表示します。この記法の詳細は <<_commit_ranges>> で説明します。

//////////////////////////
For now, we can see from the output that there is a single commit that John has made that Jessica has not merged in. If she merges `origin/master`, that is the single commit that will modify her local work.
//////////////////////////
この例では、John が作成して Jessica がまだマージしていないコミットがひとつあることがコマンド出力から読み取れます。仮にここで Jessica が `origin/master` をマージするとしましょう。その場合、Jessica の手元のファイルを変更するのは John が作成したコミットひとつだけ、という状態になります。

//////////////////////////
Now, Jessica can merge her topic work into her master branch, merge John's work (`origin/master`) into her `master` branch, and then push back to the server again.
First, she switches back to her master branch to integrate all this work:
//////////////////////////
Jessica はトピックブランチの内容を自分の master ブランチにマージし、同じく John の作業 (`origin/master`) も自分の `master` ブランチにマージして再び変更をサーバーにプッシュすることになります。まずは master ブランチに戻り、これまでの作業を統合できるようにします。

[source,console]
-----
$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
-----

//////////////////////////
She can merge either `origin/master` or `issue54` first – they're both upstream, so the order doesn't matter.
The end snapshot should be identical no matter which order she chooses; only the history will be slightly different.
She chooses to merge in `issue54` first:
//////////////////////////
`origin/master` と `issue54` のどちらからマージしてもかまいません。どちらも上流にあるので、マージする順序が変わっても結果は同じなのです。
どちらの順でマージしても、最終的なスナップショットはまったく同じものになります。ただそこにいたる歴史が微妙に変わってくるだけです。
彼女はまず `issue54` からマージすることにしました。

[source,console]
-----
$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)
-----

//////////////////////////
No problems occur; as you can see it was a simple fast-forward.
Now Jessica merges in John's work (`origin/master`):
//////////////////////////
何も問題は発生しません。ご覧の通り、単なる fast-forward です。
次に Jessica は John の作業 (`origin/master`) をマージします。

[source,console]
-----
$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

//////////////////////////
Everything merges cleanly, and Jessica's history looks like this:
//////////////////////////
こちらもうまく完了しました。Jessica の履歴はこのようになります。

//////////////////////////
.Jessica's history after merging John's changes.
image::images/small-team-6.png[Jessica's history after merging John's changes.]
//////////////////////////
.John の変更をマージした後の Jessica の履歴
image::images/small-team-6.png[John の変更をマージした後の Jessica の履歴]

//////////////////////////
Now `origin/master` is reachable from Jessica's `master` branch, so she should be able to successfully push (assuming John hasn't pushed again in the meantime):
//////////////////////////
これで、Jessica の `master` ブランチから `origin/master` に到達可能となります。これで自分の変更をプッシュできるようになりました (この作業の間に John は何もプッシュしていなかったものとします)。

[source,console]
-----
$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -> master
-----

//////////////////////////
Each developer has committed a few times and merged each other's work successfully.
//////////////////////////
各開発者が何度かコミットし、お互いの作業のマージも無事できました。

//////////////////////////
.Jessica's history after pushing all changes back to the server.
image::images/small-team-7.png[Jessica's history after pushing all changes back to the server.]
//////////////////////////
.すべての変更をサーバーに書き戻した後の Jessica の履歴
image::images/small-team-7.png[すべての変更をサーバーに書き戻した後の Jessica の履歴]

//////////////////////////
That is one of the simplest workflows.
You work for a while, generally in a topic branch, and merge into your master branch when it's ready to be integrated.
When you want to share that work, you merge it into your own master branch, then fetch and merge `origin/master` if it has changed, and finally push to the `master` branch on the server.
The general sequence is something like this:
//////////////////////////
これがもっとも単純なワークフローです。
トピックブランチでしばらく作業を進め、統合できる状態になれば自分の master ブランチにマージする。
他の開発者の作業を取り込む場合は、`origin/master` を取得してもし変更があればマージする。そして最終的にそれをサーバーの master ブランチにプッシュする。
全体的な流れは次のようになります。

//////////////////////////
.General sequence of events for a simple multiple-developer Git workflow.
image::images/small-team-flow.png[General sequence of events for a simple multiple-developer Git workflow.]
//////////////////////////
.複数開発者での Git を使ったシンプルな開発作業のイベントシーケンス
image::images/small-team-flow.png[複数開発者での Git を使ったシンプルな開発作業のイベントシーケンス]

//////////////////////////
==== Private Managed Team
//////////////////////////
==== 非公開で管理されているチーム

(((contributing, private managed team)))
//////////////////////////
In this next scenario, you'll look at contributor roles in a larger private group.
You'll learn how to work in an environment where small groups collaborate on features and then those team-based contributions are integrated by another party.
//////////////////////////
次に扱うシナリオは、大規模な非公開のグループに貢献するものです。
機能単位の小規模なグループで共同作業した結果を別のグループと統合するような環境での作業の進め方を学びましょう。

//////////////////////////
Let's say that John and Jessica are working together on one feature, while Jessica and Josie are working on a second.
In this case, the company is using a type of integration-manager workflow where the work of the individual groups is integrated only by certain engineers, and the `master` branch of the main repo can be updated only by those engineers.
In this scenario, all work is done in team-based branches and pulled together by the integrators later.
//////////////////////////
John と Jessica が共同でとある機能を実装しており、Jessica はそれとは別の件で Josie とも作業をしているものとします。
彼らの勤務先は統合マネージャー型のワークフローを採用しており、各グループの作業を統合する担当者が決まっています。メインリポジトリの `master` ブランチを更新できるのは統合担当者だけです。
この場合、すべての作業はチームごとのブランチで行われ、後で統合担当者がまとめることになります。

//////////////////////////
Let's follow Jessica's workflow as she works on her two features, collaborating in parallel with two different developers in this environment.
Assuming she already has her repository cloned, she decides to work on `featureA` first.
She creates a new branch for the feature and does some work on it there:
//////////////////////////
では、Jessica の作業の流れを追っていきましょう。彼女は二つの機能を同時に実装しており、それぞれ別の開発者と共同作業をしています。
すでに自分用のリポジトリをクローンしている彼女は、まず `featureA` の作業を始めることにしました。
この機能用に新しいブランチを作成し、そこで作業を進めます。

[source,console]
//////////////////////////
-----
# Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
-----
//////////////////////////
-----
# Jessica のマシン
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

//////////////////////////
At this point, she needs to share her work with John, so she pushes her `featureA` branch commits up to the server.
Jessica doesn't have push access to the `master` branch – only the integrators do – so she has to push to another branch in order to collaborate with John:
//////////////////////////
自分の作業内容を John に渡すため、彼女は `featureA` ブランチへのコミットをサーバーにプッシュしました。
Jessica には `master` ブランチへのプッシュをする権限はありません。そこにプッシュできるのは統合担当者だけなのです。そこで、John との共同作業用の別のブランチにプッシュします。

[source,console]
-----
$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -> featureA
-----

//////////////////////////
Jessica e-mails John to tell him that she's pushed some work into a branch named `featureA` and he can look at it now.
While she waits for feedback from John, Jessica decides to start working on `featureB` with Josie.
To begin, she starts a new feature branch, basing it off the server's `master` branch:
//////////////////////////
Jessica は John に「私の作業を `featureA` というブランチにプッシュしておいたので、見てね」というメールを送りました。
John からの返事を待つ間、Jessica はもう一方の `featureB` の作業を Josie とはじめます。
まず最初に、この機能用の新しいブランチをサーバーの `master` ブランチから作ります。

[source,console]
//////////////////////////
-----
# Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
-----
//////////////////////////
-----
# Jessicaのマシン
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
-----

//////////////////////////
Now, Jessica makes a couple of commits on the `featureB` branch:
//////////////////////////
そして Jessica は、`featureB` ブランチに何度かコミットしました。

[source,console]
-----
$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)
-----

//////////////////////////
Jessica's repository looks like this:
//////////////////////////
Jessica のリポジトリはこのようになっています。

//////////////////////////
.Jessica's initial commit history.
image::images/managed-team-1.png[Jessica's initial commit history.]
//////////////////////////
.Jessica のコミット履歴
image::images/managed-team-1.png[Jessica のコミット履歴]

//////////////////////////
She's ready to push up her work, but gets an e-mail from Josie that a branch with some initial work on it was already pushed to the server as `featureBee`.
Jessica first needs to merge those changes in with her own before she can push to the server.
She can then fetch Josie's changes down with `git fetch`:
//////////////////////////
この変更をプッシュしようと思ったそのときに、Josie から「私の作業を `featureBee` というブランチにプッシュしておいたので、見てね」というメールがやってきました。
Jessica はまずこの変更をマージしてからでないとサーバーにプッシュすることはできません。
そこで、まず Josie の変更を `git fetch` で取得しました。

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -> origin/featureBee
-----

//////////////////////////
Jessica can now merge this into the work she did with `git merge`:
//////////////////////////
次に、`git merge` でこの内容を自分の作業にマージします。

[source,console]
-----
$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)
-----

//////////////////////////
There is a bit of a problem – she needs to push the merged work in her `featureB` branch to the `featureBee` branch on the server.
She can do so by specifying the local branch followed by a colon (:) followed by the remote branch to the `git push` command:
//////////////////////////
ここでちょっとした問題が発生しました。彼女は、手元の `featureB` ブランチの内容をサーバーの `featureBee` ブランチにプッシュしなければなりません。
このような場合は、`git push` コマンドでローカルブランチ名に続けてコロン (:) を書き、その後にリモートブランチ名を指定します。

[source,console]
-----
$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -> featureBee
-----

//////////////////////////
This is called a _refspec_.
See <<_refspec>> for a more detailed discussion of Git refspecs and different things you can do with them.
Also notice the `-u` flag; this is short for `--set-upstream`, which configures the branches for easier pushing and pulling later.
//////////////////////////
これは _refspec_ と呼ばれます。
<<_refspec>> で、Git の refspec の詳細とそれで何ができるのかを説明します。
また、 `-u` オプションが使われていることにも注意しましょう。これは `--set-upstream` オプションの省略形で、のちのちブランチのプッシュ・プルで楽をするための設定です。

//////////////////////////
Next, John e-mails Jessica to say he's pushed some changes to the `featureA` branch and asks her to verify them.
She runs a `git fetch` to pull down those changes:
//////////////////////////
さて、John からメールが返ってきました。「私の変更も `featureA` ブランチにプッシュしておいたので、確認よろしく」とのことです。
彼女は `git fetch` でその変更を取り込みます。

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -> origin/featureA
-----

//////////////////////////
Then, she can see what has been changed with `git log`:
//////////////////////////
そして、`git log` で何が変わったのかを確認します。

[source,console]
-----
$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25
-----

//////////////////////////
Finally, she merges John's work into her own `featureA` branch:
//////////////////////////
確認を終えた彼女は、John の作業を自分の `featureA` ブランチにマージしました。

[source,console]
-----
$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
-----

//////////////////////////
Jessica wants to tweak something, so she commits again and then pushes this back up to the server:
//////////////////////////
Jessica はもう少し手を入れたいところがあったので、再びコミットしてそれをサーバーにプッシュします。

[source,console]
-----
$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -> featureA
-----

//////////////////////////
Jessica's commit history now looks something like this:
//////////////////////////
Jessica のコミット履歴は、この時点で以下のようになります。

//////////////////////////
.Jessica's history after committing on a feature branch.
image::images/managed-team-2.png[Jessica's history after committing on a feature branch.]
//////////////////////////
.Jessica がブランチにコミットした後のコミット履歴
image::images/managed-team-2.png[Jessica がブランチにコミットした後のコミット履歴]

//////////////////////////
Jessica, Josie, and John inform the integrators that the `featureA` and `featureBee` branches on the server are ready for integration into the mainline.
After the integrators merge these branches into the mainline, a fetch will bring down the new merge commit, making the history look like this:
//////////////////////////
Jessica、Josie そして John は、統合担当者に「`featureA` ブランチと `featureBee` ブランチは本流に統合できる状態になりました」と報告しました。
これらのブランチを担当者が本流に統合した後でそれを取得すると、マージコミットが新たに追加されてこのような状態になります。

//////////////////////////
.Jessica's history after merging both her topic branches.
image::images/managed-team-3.png[Jessica's history after merging both her topic branches.]
//////////////////////////
.Jessica が両方のトピックブランチをマージしたあとのコミット履歴
image::images/managed-team-3.png[Jessica が両方のトピックブランチをマージしたあとのコミット履歴]

//////////////////////////
Many groups switch to Git because of this ability to have multiple teams working in parallel, merging the different lines of work late in the process.
The ability of smaller subgroups of a team to collaborate via remote branches without necessarily having to involve or impede the entire team is a huge benefit of Git.
The sequence for the workflow you saw here is something like this:
//////////////////////////
Git へ移行するグループが続出しているのも、この「複数チームの作業を並行して進め、後で統合できる」という機能のおかげです。
小さなグループ単位でリモートブランチを使った共同作業ができ、しかもそれがチーム全体の作業を妨げることがない。これは Git の大きな利点です。
ここで見たワークフローをまとめると、次のようになります。

//////////////////////////
.Basic sequence of this managed-team workflow.
image::images/managed-team-flow.png[Basic sequence of this managed-team workflow.]
//////////////////////////
.管理されたチームでのワークフローの基本的な流れ
image::images/managed-team-flow.png[管理されたチームでのワークフローの基本的な流れ]

[[_public_project]]
//////////////////////////
==== Forked Public Project
//////////////////////////
==== フォークされた公開プロジェクト

(((contributing, public small project)))
//////////////////////////
Contributing to public projects is a bit different.
Because you don't have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way.
This first example describes contributing via forking on Git hosts that support easy forking.
Many hosting sites support this (including GitHub, BitBucket, Google Code, repo.or.cz, and others), and many project maintainers expect this style of contribution.
The next section deals with projects that prefer to accept contributed patches via e-mail.
//////////////////////////
公開プロジェクトに貢献するとなると、また少し話が変わってきます。
そのプロジェクトのブランチを直接更新できる権限はないでしょうから、何か別の方法でメンテナに接触する必要があります。
まずは、フォークをサポートしている Git ホスティングサービスでフォークを使って貢献する方法を説明します。
多くの Git ホスティングサービス（GitHub、 BitBucket、 Google Code、 repo.or.cz など） がフォークをサポートしており、メンテナの多くはこの方式での協力を期待しています。
そしてこの次のセクションでは、メールでパッチを送る形式での貢献について説明します。

//////////////////////////
First, you'll probably want to clone the main repository, create a topic branch for the patch or patch series you're planning to contribute, and do your work there.
The sequence looks basically like this:
//////////////////////////
まずはメインリポジトリをクローンしましょう。そしてパッチ用のトピックブランチを作り、そこで作業を進めます。
このような流れになります。

[source,console]
-----
$ git clone (url)
$ cd project
$ git checkout -b featureA
# (work)
$ git commit
# (work)
$ git commit
-----

[NOTE]
//////////////////////////
====
You may want to use `rebase -i` to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review – see <<_rewriting_history>> for more information about interactive rebasing.
====
//////////////////////////
====
`rebase -i` を使ってすべての作業をひとつのコミットにまとめたり、メンテナがレビューしやすいようにコミット内容を整理したりといったことも行うかもしれません。対話的なリベースの方法については <<_rewriting_history>> で詳しく説明します。
====

//////////////////////////
When your branch work is finished and you're ready to contribute it back to the maintainers, go to the original project page and click the ``Fork'' button, creating your own writable fork of the project.
You then need to add in this new repository URL as a second remote, in this case named `myfork`:
//////////////////////////
ブランチでの作業を終えてメンテナに渡せる状態になったら、プロジェクトのページに行って ``Fork'' ボタンを押し、自分用に書き込み可能なフォークを作成します。
このリポジトリの URL を追加のリモートとして設定しなければなりません。ここでは `myfork` という名前にしました。

[source,console]
-----
$ git remote add myfork (url)
-----

//////////////////////////
Then you need to push your work up to it.
It's easiest to push the topic branch you're working on up to your repository, rather than merging into your master branch and pushing that up.
The reason is that if the work isn't accepted or is cherry picked, you don't have to rewind your master branch.
If the maintainers merge, rebase, or cherry-pick your work, you'll eventually get it back via pulling from their repository anyhow:
//////////////////////////
今後、自分の作業内容はここにプッシュすることになります。
変更を master ブランチにマージしてからそれをプッシュするよりも、今作業中の内容をそのままトピックブランチにプッシュするほうが簡単でしょう。
もしその変更が受け入れられなかったり一部だけが取り込まれたりした場合に、master ブランチを巻き戻す必要がなくなるからです。メンテナがあなたの作業をマージするかリベースするかあるいは一部だけ取り込むか、いずれにせよあなたはその結果をリポジトリから再度取り込むことになります。

[source,console]
-----
$ git push -u myfork featureA
-----

(((git commands, request-pull)))
//////////////////////////
When your work has been pushed up to your fork, you need to notify the maintainer.
This is often called a pull request, and you can either generate it via the website – GitHub has its own Pull Request mechanism that we'll go over in <<_github>> – or you can run the `git request-pull` command and e-mail the output to the project maintainer manually.
//////////////////////////
自分用のフォークに作業内容をプッシュし終えたら、それをメンテナに伝えましょう。
これは、よく「プルリクエスト」と呼ばれるもので、ウェブサイトから実行する (GutHub には Pull request を行う独自の仕組みがあります。詳しくは <<_github>> で説明します) こともできれば、 `git request-pull` コマンドの出力をプロジェクトのメンテナにメールで送ることもできます。

//////////////////////////
The `request-pull` command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you're asking to be pulled in.
For instance, if Jessica wants to send John a pull request, and she's done two commits on the topic branch she just pushed up, she can run this:
//////////////////////////
`request-pull` コマンドには、トピックブランチをプルしてもらいたい先のブランチとその Git リポジトリの URL を指定します。すると、プルしてもらいたい変更の概要が出力されます。
たとえば Jessica が John にプルリクエストを送ろうとしたとしましょう。彼女はすでにトピックブランチ上で 2 回のコミットを済ませています。

[source,console]
-----
$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
-----

//////////////////////////
The output can be sent to the maintainer–it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.
//////////////////////////
この出力をメンテナに送れば「どのブランチからフォークしたのか、どういったコミットをしたのか、そしてそれをどこにプルしてほしいのか」を伝えることができます。

//////////////////////////
On a project for which you're not the maintainer, it's generally easier to have a branch like `master` always track `origin/master` and to do your work in topic branches that you can easily discard if they're rejected.
Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly.
For example, if you want to submit a second topic of work to the project, don't continue working on the topic branch you just pushed up – start over from the main repository's `master` branch:
//////////////////////////
自分がメンテナになっていないプロジェクトで作業をする場合は、`master` ブランチでは常に `origin/master` を追いかけるようにし、自分の作業はトピックブランチで進めていくほうが楽です。そうすれば、パッチが拒否されたときも簡単にそれを捨てることができます。
また、作業内容ごとにトピックブランチを分離しておけば、本流のリポジトリが更新されてパッチがうまく適用できなくなったとしても簡単にリベースできるようになります。
たとえば、さきほどのプロジェクトに対して別の作業をすることになったとしましょう。その場合は、先ほどプッシュしたトピックブランチを使うのではなく、メインリポジトリの `master` ブランチから新たなトピックブランチを作成します。

//////////////////////////
[source,console]
-----
$ git checkout -b featureB origin/master
# (work)
$ git commit
$ git push myfork featureB
# (email maintainer)
$ git fetch origin
-----
//////////////////////////
[source,console]
-----
$ git checkout -b featureB origin/master
# （作業）
$ git commit
$ git push myfork featureB
# （メンテナにメールを送る）
$ git fetch origin
-----

//////////////////////////
Now, each of your topics is contained within a silo – similar to a patch queue – that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other, like so:
//////////////////////////
これで、それぞれのトピックがサイロに入った状態になりました。お互いのトピックが邪魔しあったり依存しあったりすることなく、それぞれ個別に書き換えやリベースが可能となります。詳しくは以下を参照ください。

//////////////////////////
.Initial commit history with `featureB` work.
image::images/public-small-1.png[Initial commit history with `featureB` work.]
//////////////////////////
.`featureB` に関する作業のコミット履歴
image::images/public-small-1.png[`featureB` に関する作業のコミット履歴]

//////////////////////////
Let's say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges.
In this case, you can try to rebase that branch on top of `origin/master`, resolve the conflicts for the maintainer, and then resubmit your changes:
//////////////////////////
プロジェクトのメンテナが、他の大量のパッチを適用したあとであなたの最初のパッチを適用しようとしました。しかしその時点でパッチはすでにそのままでは適用できなくなっています。
こんな場合は、そのブランチを `origin/master` の先端にリベースして衝突を解決させ、あらためて変更内容をメンテナに送ります。

[source,console]
-----
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
-----

//////////////////////////
This rewrites your history to now look like <<psp_b>>.
//////////////////////////
これで、あなたの歴史は <<psp_b>> のように書き換えられました。

[[psp_b]]
//////////////////////////
.Commit history after `featureA` work.
image::images/public-small-2.png[Commit history after `featureA` work.]
//////////////////////////
.`featureA` の作業を終えた後のコミット履歴
image::images/public-small-2.png[`featureA` の作業を終えた後のコミット履歴]

//////////////////////////
Because you rebased the branch, you have to specify the `-f` to your push command in order to be able to replace the `featureA` branch on the server with a commit that isn't a descendant of it.
An alternative would be to push this new work to a different branch on the server (perhaps called `featureAv2`).
//////////////////////////
ブランチをリベースしたので、プッシュする際には `-f` を指定しなければなりません。これは、サーバー上の `featureA` ブランチをその直系の子孫以外のコミットで上書きするためです。
別のやり方として、今回の作業を別のブランチ (`featureAv2` など) にプッシュすることもできます。

//////////////////////////
Let's look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.
You'll also take this opportunity to move the work to be based off the project's current `master` branch.
You start a new branch based off the current `origin/master` branch, squash the `featureB` changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:
//////////////////////////
もうひとつ別のシナリオを考えてみましょう。あなたの二番目のブランチを見たメンテナが、その考え方は気に入ったものの細かい実装をちょっと変更してほしいと連絡してきました。
この場合も、プロジェクトの `master` ブランチから作業を進めます。
現在の `origin/master` から新たにブランチを作成し、そこに `featureB` ブランチの変更を押し込み、もし衝突があればそれを解決し、実装をちょっと変更してからそれを新しいブランチとしてプッシュします。

(((git commands, merge, squash)))
[source,console]
//////////////////////////
-----
$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
# (change implementation)
$ git commit
$ git push myfork featureBv2
-----
//////////////////////////
-----
$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
# （実装をちょっと変更する）
$ git commit
$ git push myfork featureBv2
-----

//////////////////////////
The `--squash` option takes all the work on the merged branch and squashes it into one non-merge commit on top of the branch you're on.
The `--no-commit` option tells Git not to automatically record a commit.
This allows you to introduce all the changes from another branch and then make more changes before recording the new commit.
//////////////////////////
`--squash` オプションは、マージしたいブランチでのすべての作業をひとつのコミットにまとめ、それを現在のブランチの先頭にマージします。
`--no-commit` オプションは、自動的にコミットを記録しないよう Git に指示しています。
こうすれば、別のブランチのすべての変更を取り込んでさらに手元で変更を加えたものを新しいコミットとして記録できるのです。

//////////////////////////
Now you can send the maintainer a message that you've made the requested changes and they can find those changes in your `featureBv2` branch.
//////////////////////////
そして、メンテナに「言われたとおりのちょっとした変更をしたものが `featureBv2` ブランチにあるよ」と連絡します。

//////////////////////////
.Commit history after `featureBv2` work.
image::images/public-small-3.png[Commit history after `featureBv2` work.]
//////////////////////////
.`featureBv2` の作業を終えた後のコミット履歴
image::images/public-small-3.png[`featureBv2` の作業を終えた後のコミット履歴]

[[_project_over_email]]
//////////////////////////
==== Public Project over E-Mail
//////////////////////////
==== メールを使った公開プロジェクトへの貢献

(((contributing, public large project)))
//////////////////////////
Many projects have established procedures for accepting patches – you'll need to check the specific rules for each project, because they will differ.
Since there are several older, larger projects which accept patches via a developer mailing list, we'll go over an example of that now.
//////////////////////////
多くのプロジェクトでは、パッチを受け付ける手続きが確立されています。プロジェクトによっていろいろ異なるので、まずはそのプロジェクト固有のルールがないかどうか確認しましょう。
また、長期間続いている大規模なプロジェクトには、開発者用メーリングリストでパッチを受け付けているものがいくつかあります。そこで、ここではそういったプロジェクトを例にとって話を進めます。

//////////////////////////
The workflow is similar to the previous use case – you create topic branches for each patch series you work on.
The difference is how you submit them to the project.
Instead of forking the project and pushing to your own writable version, you generate e-mail versions of each commit series and e-mail them to the developer mailing list:
//////////////////////////
実際の作業の流れは先ほどとほぼ同じで、作業する内容ごとにトピックブランチを作成することになります。
違うのは、パッチをプロジェクトに提供する方法です。
プロジェクトをフォークし、自分用のリポジトリにプッシュするのではなく、個々のコミットについてメールを作成し、それを開発者用メーリングリストに投稿します。

[source,console]
//////////////////////////
-----
$ git checkout -b topicA
# (work)
$ git commit
# (work)
$ git commit
-----
//////////////////////////
-----
$ git checkout -b topicA
# （作業）
$ git commit
# （作業）
$ git commit
-----

(((git commands, format-patch)))
//////////////////////////
Now you have two commits that you want to send to the mailing list.
You use `git format-patch` to generate the mbox-formatted files that you can e-mail to the list – it turns each commit into an e-mail message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.
The nice thing about this is that applying a patch from an e-mail generated with `format-patch` preserves all the commit information properly.
//////////////////////////
これで二つのコミットができあがりました。これらをメーリングリストに投稿します。
`git format-patch` を使うと mbox 形式のファイルが作成されるので、これをメーリングリストに送ることができます。このコマンドは、コミットメッセージの一行目を件名、残りのコミットメッセージとコミット内容のパッチを本文に書いたメールを作成します。
これのよいところは、`format-patch` で作成したメールからパッチを適用すると、すべてのコミット情報が適切に維持されるというところです。

[source,console]
-----
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
-----

//////////////////////////
The `format-patch` command prints out the names of the patch files it creates.
The `-M` switch tells Git to look for renames.
The files end up looking like this:
//////////////////////////
`format-patch` コマンドは、できあがったパッチファイルの名前を出力します。
`-M` スイッチは、名前が変わったことを検出するためのものです。
できあがったファイルは次のようになります。

[source,console]
-----
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0
-----

//////////////////////////
You can also edit these patch files to add more information for the e-mail list that you don't want to show up in the commit message.
If you add text between the `---` line and the beginning of the patch (the `diff --git` line), then developers can read it; but applying the patch excludes it.
//////////////////////////
このファイルを編集して、コミットメッセージには書けなかったような情報をメーリングリスト用に追加することもできます。
`---` の行とパッチの開始位置 ( `diff --git` の行) の間にメッセージを書くと、メールを受信した人はそれを読むことができますが、パッチからは除外されます。

//////////////////////////
To e-mail this to a mailing list, you can either paste the file into your e-mail program or send it via a command-line program.
Pasting the text often causes formatting issues, especially with ``smarter'' clients that don't preserve newlines and other whitespace appropriately.
Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you.
We'll demonstrate how to send a patch via Gmail, which happens to be the e-mail agent we know best; you can read detailed instructions for a number of mail programs at the end of the aforementioned `Documentation/SubmittingPatches` file in the Git source code.
//////////////////////////
これをメーリングリストに投稿するには、メールソフトにファイルの内容を貼り付けるか、あるいはコマンドラインのプログラムを使います。
ファイルの内容をコピーして貼り付けると「かしこい」メールソフトが勝手に改行の位置を変えてしまうなどの問題が起こりがちです。
ありがたいことに Git には、きちんとしたフォーマットのパッチを IMAP で送ることを支援するツールが用意されています。これを使うと便利です。
ここでは、パッチを Gmail で送る方法を説明しましょう。というのも、一番よく知っているメールソフトが Gmail だからです。さまざまなメールソフトでの詳細なメール送信方法が、Git ソースコードにある `Documentation/SubmittingPatches` の最後に載っています。

(((git commands, config)))(((email)))
//////////////////////////
First, you need to set up the imap section in your `~/.gitconfig` file.
You can set each value separately with a series of `git config` commands, or you can add them manually, but in the end your config file should look something like this:
//////////////////////////
まず。`~/.gitconfig` ファイルの imap セクションを設定します。
それぞれの値を `git config` コマンドで順に設定してもかまいませんし、このファイルに手で書き加えてもかまいません。最終的に、設定ファイルは次のようになります。

[source,ini]
-----
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false
-----

//////////////////////////
If your IMAP server doesn't use SSL, the last two lines probably aren't necessary, and the host value will be `imap://` instead of `imaps://`.
When that is set up, you can use `git send-email` to place the patch series in the Drafts folder of the specified IMAP server:
//////////////////////////
IMAP サーバーで SSL を使っていない場合は、最後の二行はおそらく不要でしょう。そして host のところが `imaps://` ではなく `imap://` となります。
ここまでの設定が終われば、`git send-email` を実行して IMAP サーバーの Drafts フォルダにパッチを置くことができるようになります。

[source,console]
-----
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
-----

//////////////////////////
Then, Git spits out a bunch of log information looking something like this for each patch you're sending:
//////////////////////////
Git はその後、各パッチについてこのようなログ情報をはき出すはずです。

[source,text]
-----
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
  \line 'From: Jessica Smith <jessica@example.com>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>

Result: OK
-----

//////////////////////////
At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you're sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.
//////////////////////////
あとは、Drafts フォルダに移動して To フィールドをメーリングリストのアドレスに変更し (おそらく CC には担当メンテなのアドレスを入れ)、送信できるようになりました。

//////////////////////////
==== Summary
//////////////////////////
==== まとめ

//////////////////////////
This section has covered a number of common workflows for dealing with several very different types of Git projects you're likely to encounter, and introduced a couple of new tools to help you manage this process.
Next, you'll see how to work the other side of the coin: maintaining a Git project.
You'll learn how to be a benevolent dictator or integration manager.
//////////////////////////
このセクションでは、今後みなさんが遭遇するであろうさまざまな形式の Git プロジェクトについて、関わっていくための作業手順を説明しました。そして、その際に使える新兵器もいくつか紹介しました。
次はもう一方の側、つまり Git プロジェクトを運営する側について見ていきましょう。
慈悲深い独裁者、あるいは統合マネージャーとしての作業手順を説明します。
