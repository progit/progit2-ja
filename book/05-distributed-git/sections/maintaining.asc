//////////////////////////
=== Maintaining a Project
//////////////////////////
=== プロジェクトの運営

(((maintaining a project)))
//////////////////////////
In addition to knowing how to effectively contribute to a project, you'll likely need to know how to maintain one.
This can consist of accepting and applying patches generated via `format-patch` and e-mailed to you, or integrating changes in remote branches for repositories you've added as remotes to your project.
Whether you maintain a canonical repository or want to help by verifying or approving patches, you need to know how to accept work in a way that is clearest for other contributors and sustainable by you over the long run.
//////////////////////////
プロジェクトに貢献する方法だけでなく、プロジェクトを運営する方法についても知っておくといいでしょう。
たとえば `format-patch` を使ってメールで送られてきたパッチを処理する方法や、別のリポジトリのリモートブランチでの変更を統合する方法などです。
本流のリポジトリを保守するにせよパッチの検証や適用を手伝うにせよ、どうすれば貢献者たちにとってわかりやすくなるかを知っておくべきでしょう。

//////////////////////////
==== Working in Topic Branches
//////////////////////////
==== トピックブランチでの作業

(((branches, topic)))
//////////////////////////
When you're thinking of integrating new work, it's generally a good idea to try it out in a topic branch – a temporary branch specifically made to try out that new work.
This way, it's easy to tweak a patch individually and leave it if it's not working until you have time to come back to it.
If you create a simple branch name based on the theme of the work you're going to try, such as `ruby_client` or something similarly descriptive, you can easily remember it if you have to abandon it for a while and come back later.
The maintainer of the Git project tends to namespace these branches as well – such as `sc/ruby_client`, where `sc` is short for the person who contributed the work.
As you'll remember, you can create the branch based off your master branch like this:
//////////////////////////
新しい機能を組み込もうと考えている場合は、トピックブランチを作ることをおすすめします。トピックブランチとは、新しく作業を始めるときに一時的に作るブランチのことです。
そうすれば、そのパッチだけを個別にいじることができ、もしうまくいかなかったとしてもすぐに元の状態に戻すことができます。
ブランチの名前は、今からやろうとしている作業の内容にあわせたシンプルな名前にしておきます。たとえば `ruby_client` などといったものです。そうすれば、しばらく時間をおいた後でそれを廃棄することになったときに、内容を思い出しやすくなります。
Git プロジェクトのメンテナは、ブランチ名に名前空間を使うことが多いようです。たとえば `sc/ruby_client` のようになり、ここでの `sc` はその作業をしてくれた人の名前を短縮したものとなります。
自分の master ブランチをもとにしたブランチを作成する方法は、このようになります。

[source,console]
-----
$ git branch sc/ruby_client master
-----

//////////////////////////
Or, if you want to also switch to it immediately, you can use the `checkout -b` option:
//////////////////////////
作成してすぐそのブランチに切り替えたい場合は、`checkout -b` オプションを使います。

[source,console]
-----
$ git checkout -b sc/ruby_client master
-----

//////////////////////////
Now you're ready to add your contributed work into this topic branch and determine if you want to merge it into your longer-term branches.
//////////////////////////
受け取った作業はこのトピックブランチですすめ、長期ブランチに統合するかどうかを判断することになります。

[[_patches_from_email]]
//////////////////////////
==== Applying Patches from E-mail
//////////////////////////
==== メールで受け取ったパッチの適用

(((email, applying patches from)))
//////////////////////////
If you receive a patch over e-mail that you need to integrate into your project, you need to apply the patch in your topic branch to evaluate it.
There are two ways to apply an e-mailed patch: with `git apply` or with `git am`.
//////////////////////////
あなたのプロジェクトへのパッチをメールで受け取った場合は、まずそれをトピックブランチに適用して中身を検証します。
メールで届いたパッチを適用するには `git apply` と `git am` の二通りの方法があります。

//////////////////////////
===== Applying a Patch with apply
//////////////////////////
===== apply によるパッチの適用

(((git commands, apply)))
//////////////////////////
If you received the patch from someone who generated it with the `git diff` or a Unix `diff` command (which is not recommended; see the next section), you can apply it with the `git apply` command.
Assuming you saved the patch at `/tmp/patch-ruby-client.patch`, you can apply the patch like this:
//////////////////////////
`git diff` あるいは Unix の `diff` コマンドで作ったパッチ（パッチの作り方としては推奨できません。次節で理由を説明します）を受け取ったときは、`git apply` コマンドを使ってパッチを適用します。
パッチが `/tmp/patch-ruby-client.patch` にあるとすると、このようにすればパッチを適用できます。

[source,console]
-----
$ git apply /tmp/patch-ruby-client.patch
-----

//////////////////////////
This modifies the files in your working directory.
It's almost identical to running a `patch -p1` command to apply the patch, although it's more paranoid and accepts fewer fuzzy matches than patch.
It also handles file adds, deletes, and renames if they're described in the `git diff` format, which `patch` won't do.
Finally, `git apply` is an ``apply all or abort all'' model where either everything is applied or nothing is, whereas `patch` can partially apply patchfiles, leaving your working directory in a weird state.
`git apply` is overall much more conservative than `patch`.
It won't create a commit for you – after running it, you must stage and commit the changes introduced manually.
//////////////////////////
これは、作業ディレクトリ内のファイルを変更します。
`patch -p1` コマンドでパッチをあてるのとほぼ同じなのですが、それ以上に「これでもか」というほどのこだわりを持ってパッチを適用するので fuzzy マッチになる可能性が少なくなります。
また、`git diff` 形式ではファイルの追加・削除やファイル名の変更も扱うことができますが、`patch` コマンドにはそれはできません。
そして最後に、`git apply` は「全部適用するか、あるいは一切適用しないか」というモデルを採用しています。一方 `patch` コマンドの場合は、途中までパッチがあたった中途半端な状態になって困ることがあります。
`git apply` のほうが、 `patch` よりも慎重に処理を行うのです。
`git apply` コマンドはコミットを作成するわけではありません。実行した後で、その変更をステージしてコミットする必要があります。

//////////////////////////
You can also use git apply to see if a patch applies cleanly before you try actually applying it – you can run `git apply --check` with the patch:
//////////////////////////
git apply を使って、そのパッチをきちんと適用できるかどうかを事前に確かめることができます。パッチをチェックするには `git apply --check` を実行します。

[source,console]
-----
$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
-----

//////////////////////////
If there is no output, then the patch should apply cleanly.
This command also exits with a non-zero status if the check fails, so you can use it in scripts if you want.
//////////////////////////
何も出力されなければ、そのパッチはうまく適用できるということです。
このコマンドは、チェックに失敗した場合にゼロ以外の値を返して終了します。スクリプト内でチェックしたい場合などにはこの返り値を使用します。

[[_git_am]]
//////////////////////////
===== Applying a Patch with `am`
//////////////////////////
===== `am` でのパッチの適用

(((git commands, am)))
//////////////////////////
If the contributor is a Git user and was good enough to use the `format-patch` command to generate their patch, then your job is easier because the patch contains author information and a commit message for you.
If you can, encourage your contributors to use `format-patch` instead of `diff` to generate patches for you.
You should only have to use `git apply` for legacy patches and things like that.
//////////////////////////
コードを提供してくれた人が Git のユーザーで、`format-patch` コマンドを使ってパッチを送ってくれたとしましょう。この場合、あなたの作業はより簡単になります。パッチの中に、作者の情報やコミットメッセージも含まれているからです。
「パッチを作るときには、できるだけ `diff` ではなく `format-patch` を使ってね」とお願いしてみるのもいいでしょう。
昔ながらの形式のパッチが届いたときだけは `git apply` を使わなければならなくなります。

//////////////////////////
To apply a patch generated by `format-patch`, you use `git am`.
Technically, `git am` is built to read an mbox file, which is a simple, plain-text format for storing one or more e-mail messages in one text file.
It looks something like this:
//////////////////////////
`format-patch` で作ったパッチを適用するには `git am` を使います。技術的なお話をすると、`git am` は mbox ファイルを読み込む仕組みになっています。mbox はシンプルなプレーンテキスト形式で、一通あるいは複数のメールのメッセージをひとつのテキストファイルにまとめるためのものです。中身はこのようになります。

[source,console]
-----
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20
-----

//////////////////////////
This is the beginning of the output of the format-patch command that you saw in the previous section.
This is also a valid mbox e-mail format.
If someone has e-mailed you the patch properly using git send-email, and you download that into an mbox format, then you can point git am to that mbox file, and it will start applying all the patches it sees.
If you run a mail client that can save several e-mails out in mbox format, you can save entire patch series into a file and then use git am to apply them one at a time.
//////////////////////////
先ほどのセクションでごらんいただいたように、format-patch コマンドの出力結果もこれと同じ形式で始まっていますね。
これは、mbox 形式のメールフォーマットとしても正しいものです。
git send-email を正しく使ったパッチが送られてきた場合、受け取ったメールを mbox 形式で保存して git am コマンドでそのファイルを指定すると、すべてのパッチの適用が始まります。
複数のメールをまとめてひとつの mbox に保存できるメールソフトを使っていれば、送られてきたパッチをひとつのファイルにまとめて git am で一度に適用することもできます。

//////////////////////////
However, if someone uploaded a patch file generated via `format-patch` to a ticketing system or something similar, you can save the file locally and then pass that file saved on your disk to `git am` to apply it:
//////////////////////////
しかし、`format-patch` で作ったパッチがチケットシステム (あるいはそれに類する何か) にアップロードされたような場合は、まずそのファイルをローカルに保存して、それを `git am` に渡すことになります。

[source,console]
-----
$ git am 0001-limit-log-function.patch
Applying: add limit to log function
-----

//////////////////////////
You can see that it applied cleanly and automatically created the new commit for you.
The author information is taken from the e-mail's `From` and `Date` headers, and the message of the commit is taken from the `Subject` and body (before the patch) of the e-mail.
For example, if this patch was applied from the mbox example above, the commit generated would look something like this:
//////////////////////////
どんなパッチを適用したのかが表示され、コミットも自動的に作られます。作者の情報はメールの `From` ヘッダと `Date` ヘッダから取得し、コミットメッセージは `Subject` とメールの本文 (パッチより前の部分) から取得します。たとえば、先ほどごらんいただいた mbox の例にあるパッチを適用した場合は次のようなコミットとなります。

-----
$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith <jessica@example.com>
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon <schacon@gmail.com>
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20
-----

//////////////////////////
The `Commit` information indicates the person who applied the patch and the time it was applied.
The `Author` information is the individual who originally created the patch and when it was originally created.
//////////////////////////
`Commit` には、そのパッチを適用した人と適用した日時が表示されます。
`Author` には、そのパッチを実際に作成した人と作成した日時が表示されます。

//////////////////////////
But it's possible that the patch won't apply cleanly.
Perhaps your main branch has diverged too far from the branch the patch was built from, or the patch depends on another patch you haven't applied yet.
In that case, the `git am` process will fail and ask you what you want to do:
//////////////////////////
しかし、パッチが常にうまく適用できるとは限りません。
パッチを作成したときの状態と現在のメインブランチとが大きくかけ離れてしまっていたり、そのパッチが別の (まだ適用していない) パッチに依存していたりなどといったことがあり得るでしょう。
そんな場合は `git am` は失敗し、次にどうするかを聞かれます。

[source,console]
-----
$ git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run "git am --resolved".
If you would prefer to skip this patch, instead run "git am --skip".
To restore the original branch and stop patching run "git am --abort".
-----

//////////////////////////
This command puts conflict markers in any files it has issues with, much like a conflicted merge or rebase operation.
You solve this issue much the same way – edit the file to resolve the conflict, stage the new file, and then run `git am --resolved` to continue to the next patch:
//////////////////////////
このコマンドは、何か問題が発生したファイルについて衝突マークを書き込みます。これは、マージやリベースに失敗したときに書き込まれるのとよく似たものです。
問題を解決する方法も同じです。まずはファイルを編集して衝突を解決し、新しいファイルをステージし、`git am --resolved` を実行して次のパッチに進みます。

[source,console]
//////////////////////////
-----
$ (fix the file)
$ git add ticgit.gemspec
$ git am --resolved
Applying: seeing if this helps the gem
-----
//////////////////////////
-----
$ （ファイルを編集する）
$ git add ticgit.gemspec
$ git am --resolved
Applying: seeing if this helps the gem
-----

//////////////////////////
If you want Git to try a bit more intelligently to resolve the conflict, you can pass a `-3` option to it, which makes Git attempt a three-way merge.
This option isn't on by default because it doesn't work if the commit the patch says it was based on isn't in your repository.
If you do have that commit – if the patch was based on a public commit – then the `-3` option is generally much smarter about applying a conflicting patch:
//////////////////////////
Git にもうちょっと賢く働いてもらって衝突を回避したい場合は、`-3` オプションを使用します。これは、Git で三方向のマージを行うオプションです。
このオプションはデフォルトでは有効になっていません。適用するパッチの元になっているコミットがあなたのリポジトリ上のものでない場合に正しく動作しないからです。
パッチの元になっているコミットが手元にある場合は、`-3` オプションを使うと、衝突しているパッチをうまく適用できます。

[source,console]
-----
$ git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.
-----

//////////////////////////
In this case, this patch had already been applied.
Without the `-3` option, it looks like a conflict.
//////////////////////////
ここでは、既に適用済みのパッチを適用してみました。
`-3` オプションがなければ、衝突が発生していたことでしょう。

//////////////////////////
If you're applying a number of patches from an mbox, you can also run the `am` command in interactive mode, which stops at each patch it finds and asks if you want to apply it:
//////////////////////////
たくさんのパッチが含まれる mbox からパッチを適用するときには、`am` コマンドを対話モードで実行することもできます。パッチが見つかるたびに処理を止め、それを適用するかどうかの確認を求められます。

[source,console]
-----
$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all
-----

//////////////////////////
This is nice if you have a number of patches saved, because you can view the patch first if you don't remember what it is, or not apply the patch if you've already done so.
//////////////////////////
これは、「大量にあるパッチについて、内容をまず一通り確認したい」「既に適用済みのパッチは適用しないようにしたい」などの場合に便利です。

//////////////////////////
When all the patches for your topic are applied and committed into your branch, you can choose whether and how to integrate them into a longer-running branch.
//////////////////////////
トピックブランチ上でそのトピックに関するすべてのパッチの適用を済ませてコミットすれば、次はそれを長期ブランチに統合するかどうか (そしてどのように統合するか) を考えることになります。

[[_checking_out_remotes]]
//////////////////////////
==== Checking Out Remote Branches
//////////////////////////
==== リモートブランチのチェックアウト

(((branches, remote)))
//////////////////////////
If your contribution came from a Git user who set up their own repository, pushed a number of changes into it, and then sent you the URL to the repository and the name of the remote branch the changes are in, you can add them as a remote and do merges locally.
//////////////////////////
自前のリポジトリを持つ Git ユーザーが自分のリポジトリに変更をプッシュし、そのリポジトリの URL とリモートブランチ名だけをあなたにメールで連絡してきた場合のことを考えてみましょう。そのリポジトリをリモートとして登録し、それをローカルにマージすることになります。

//////////////////////////
For instance, if Jessica sends you an e-mail saying that she has a great new feature in the `ruby-client` branch of her repository, you can test it by adding the remote and checking out that branch locally:
//////////////////////////
Jessica から「すばらしい新機能を作ったので、私のリポジトリの `ruby-client` ブランチを見てください」といったメールが来たとします。これを手元でテストするには、リモートとしてこのリポジトリを追加し、ローカルにブランチをチェックアウトします。

[source,console]
-----
$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client
-----

//////////////////////////
If she e-mails you again later with another branch containing another great feature, you can fetch and check out because you already have the remote setup.
//////////////////////////
「この前のとは違う、別のすばらしい機能を作ったの!」と別のブランチを伝えられた場合は、すでにリモートの設定が済んでいるので単にそのブランチを取得してチェックアウトするだけで確認できます。

//////////////////////////
This is most useful if you're working with a person consistently.
If someone only has a single patch to contribute once in a while, then accepting it over e-mail may be less time consuming than requiring everyone to run their own server and having to continually add and remove remotes to get a few patches.
You're also unlikely to want to have hundreds of remotes, each for someone who contributes only a patch or two.
However, scripts and hosted services may make this easier – it depends largely on how you develop and how your contributors develop.
//////////////////////////
この方法は、誰かと継続的に共同作業を進めていく際に便利です。
ちょっとしたパッチをたまに提供してくれるだけの人の場合は、パッチをメールで受け取るようにしたほうが時間の節約になるでしょう。全員に自前のサーバーを用意させて、たまに送られてくるパッチを取得するためだけに定期的にリモートの追加と削除を行うなどというのは時間の無駄です。
ほんの数件のパッチを提供してくれる人たちを含めて数百ものリモートを管理することなど、きっとあなたはお望みではないでしょう。
しかし、スクリプトやホスティングサービスを使えばこの手の作業は楽になります。つまり、どのような方式をとるかは、あなたや他のメンバーがどのような方式で開発を進めるかによって決まります。

//////////////////////////
The other advantage of this approach is that you get the history of the commits as well.
Although you may have legitimate merge issues, you know where in your history their work is based; a proper three-way merge is the default rather than having to supply a `-3` and hope the patch was generated off a public commit to which you have access.
//////////////////////////
この方式のもうひとつの利点は、コミットの履歴も同時に取得できるということです。
マージの際に問題が起こることもあるでしょうが、そんな場合にも相手の作業が自分側のどの地点に基づくものなのかを知ることができます。適切に三方向のマージが行われるので、`-3` を指定したときに「このパッチの基点となるコミットにアクセスできればいいなぁ」と祈る必要はありません。

//////////////////////////
If you aren't working with a person consistently but still want to pull from them in this way, you can provide the URL of the remote repository to the `git pull` command.
This does a one-time pull and doesn't save the URL as a remote reference:
//////////////////////////
継続的に共同作業を続けるわけではないけれど、それでもこの方式でパッチを取得したいという場合は、リモートリポジトリの URL を `git pull` コマンドで指定することもできます。
これは一度きりのプルに使うものであり、リモートを参照する URL は保存されません。

[source,console]
-----
$ git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
 * branch            HEAD       -> FETCH_HEAD
Merge made by recursive.
-----

[[_what_is_introduced]]
//////////////////////////
==== Determining What Is Introduced
//////////////////////////
==== 何が変わるのかの把握

(((branches, diffing)))
//////////////////////////
Now you have a topic branch that contains contributed work.
At this point, you can determine what you'd like to do with it.
This section revisits a couple of commands so you can see how you can use them to review exactly what you'll be introducing if you merge this into your main branch.
//////////////////////////
トピックブランチの中に、提供してもらった作業が含まれた状態になりました。
次に何をすればいいのか考えてみましょう。
このセクションでは、これまでに扱ったいくつかのコマンドを復習します。それらを使って、もしこの変更をメインブランチにマージしたらいったい何が起こるのかを調べていきましょう。

//////////////////////////
It's often helpful to get a review of all the commits that are in this branch but that aren't in your master branch.
You can exclude commits in the master branch by adding the `--not` option before the branch name.
This does the same thing as the `master..contrib` format that we used earlier.
For example, if your contributor sends you two patches and you create a branch called `contrib` and applied those patches there, you can run this:
//////////////////////////
トピックブランチのコミットのうち、master ブランチに存在しないコミットの内容をひとつひとつレビューできれば便利でしょう。
master ブランチに含まれるコミットを除外するには、ブランチ名の前に `--not` オプションを指定します。
これは、これまで使ってきた `master..contrib` という書式と同じ役割を果たしてくれます。
たとえば、誰かから受け取った二つのパッチを適用するために `contrib` というブランチを作成したとすると、

[source,console]
-----
$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon <schacon@gmail.com>
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better
-----

//////////////////////////
To see what changes each commit introduces, remember that you can pass the `-p` option to `git log` and it will append the diff introduced to each commit.
//////////////////////////
このようなコマンドを実行すればそれぞれのコミットの内容を確認できます。`git log` に `-p` オプションを渡せば、コミットの後に diff を表示させることもできます。これも以前に説明しましたね。

//////////////////////////
To see a full diff of what would happen if you were to merge this topic branch with another branch, you may have to use a weird trick to get the correct results.
You may think to run this:
//////////////////////////
このトピックブランチを別のブランチにマージしたときに何が起こるのかを完全な diff で知りたい場合は、ちょっとした裏技を使わないと正しい結果が得られません。
おそらく「こんなコマンドを実行するだけじゃないの?」と考えておられることでしょう。

[source,console]
-----
$ git diff master
-----

//////////////////////////
This command gives you a diff, but it may be misleading.
If your `master` branch has moved forward since you created the topic branch from it, then you'll get seemingly strange results.
This happens because Git directly compares the snapshots of the last commit of the topic branch you're on and the snapshot of the last commit on the `master` branch.
For example, if you've added a line in a file on the `master` branch, a direct comparison of the snapshots will look like the topic branch is going to remove that line.
//////////////////////////
このコマンドで表示される diff は、誤解を招きかねないものです。
トピックブランチを切った時点からさらに `master` ブランチが先に進んでいたとすると、これは少し奇妙に見える結果を返します。
というのも、Git は現在のトピックブランチの最新のコミットのスナップショットと `master` ブランチの最新のコミットのスナップショットを直接比較するからです。
トピックブランチを切った後に `master` ブランチ上であるファイルに行を追加したとすると、スナップショットを比較した結果は「トピックブランチでその行を削除しようとしている」状態になります。

//////////////////////////
If `master` is a direct ancestor of your topic branch, this isn't a problem; but if the two histories have diverged, the diff will look like you're adding all the new stuff in your topic branch and removing everything unique to the `master` branch.
//////////////////////////
`master` がトピックブランチの直系の先祖である場合は、これは特に問題とはなりません。しかし二つの歴史が分岐している場合には、diff の結果は「トピックブランチで新しく追加したすべての内容を追加し、`master` ブランチにしかないものはすべて削除する」というものになります。

//////////////////////////
What you really want to see are the changes added to the topic branch – the work you'll introduce if you merge this branch with master.
You do that by having Git compare the last commit on your topic branch with the first common ancestor it has with the master branch.
//////////////////////////
本当に知りたいのはトピックブランチで変更された内容、つまりこのブランチを master にマージしたときに master に加わる変更です。
これを知るには、Git に「トピックブランチの最新のコミット」と「トピックブランチと master ブランチの直近の共通の先祖」とを比較させます。

//////////////////////////
Technically, you can do that by explicitly figuring out the common ancestor and then running your diff on it:
//////////////////////////
共通の先祖を見つけだしてそこからの diff を取得するには、このようにします。

[source,console]
-----
$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db
-----

//////////////////////////
However, that isn't convenient, so Git provides another shorthand for doing the same thing: the triple-dot syntax.
In the context of the `diff` command, you can put three periods after another branch to do a `diff` between the last commit of the branch you're on and its common ancestor with another branch:
//////////////////////////
しかし、これでは不便です。そこで Git には、同じことをより手短にやるための手段としてトリプルドット構文が用意されています。
`diff` コマンドを実行するときにピリオドを三つ打った後に別のブランチを指定すると、「現在いるブランチの最新のコミット」と「指定した二つのブランチの共通の先祖」とを比較するようになります。

[source,console]
-----
$ git diff master...contrib
-----

//////////////////////////
This command shows you only the work your current topic branch has introduced since its common ancestor with master.
That is a very useful syntax to remember.
//////////////////////////
このコマンドは、master との共通の先祖から分岐した現在のトピックブランチで変更された内容のみを表示します。
この構文は、覚えやすいので非常に便利です。

//////////////////////////
==== Integrating Contributed Work
//////////////////////////
==== 提供された作業の取り込み

(((integrating work)))
//////////////////////////
When all the work in your topic branch is ready to be integrated into a more mainline branch, the question is how to do it.
Furthermore, what overall workflow do you want to use to maintain your project?
You have a number of choices, so we'll cover a few of them.
//////////////////////////
トピックブランチでの作業をメインブランチに取り込む準備ができたら、どのように取り込むかを考えることになります。
さらに、プロジェクトを運営していくにあたっての全体的な作業の流れはどのようにしたらいいでしょうか?
さまざまな方法がありますが、ここではそのうちのいくつかを紹介します。

//////////////////////////
===== Merging Workflows
//////////////////////////
===== マージのワークフロー

(((workflows, merging)))
//////////////////////////
One simple workflow merges your work into your `master` branch.
In this scenario, you have a `master` branch that contains basically stable code.
When you have work in a topic branch that you've done or that someone has contributed and you've verified, you merge it into your master branch, delete the topic branch, and then continue the process.
If we have a repository with work in two branches named `ruby_client` and `php_client` that looks like <<merwf_a>> and merge `ruby_client` first and then `php_client` next, then your history will end up looking like <<merwf_b>>.
//////////////////////////
シンプルなワークフローのひとつとして、作業を自分の `master` ブランチに取り込むことを考えます。
ここでは、`master` ブランチで安定版のコードを管理しているものとします。
トピックブランチでの作業が一段落したら (あるいは誰かから受け取ったパッチをトピックブランチ上で検証し終えたら)、それを master ブランチにマージしてからトピックブランチを削除し、作業を進めることになります。
`ruby_client` および `php_client` の二つのブランチを持つ <<merwf_a>> のようなリポジトリでまず `ruby_client` をマージしてから `php_client` もマージすると、歴史は <<merwf_b>> のようになります。

[[merwf_a]]
//////////////////////////
.History with several topic branches.
image::images/merging-workflows-1.png[History with several topic branches.]
//////////////////////////
.いくつかのトピックブランチを含む履歴
image::images/merging-workflows-1.png[いくつかのトピックブランチを含む履歴]

[[merwf_b]]
//////////////////////////
.After a topic branch merge.
image::images/merging-workflows-2.png[After a topic branch merge.]
//////////////////////////
.トピックブランチをマージした後の状態
image::images/merging-workflows-2.png[トピックブランチをマージした後の状態]

//////////////////////////
That is probably the simplest workflow, but it can possibly be problematic if you're dealing with larger or more stable projects where you want to be really careful about what you introduce.
//////////////////////////
これがおそらく一番シンプルなワークフローでしょう。ただし、それが問題になることもあります。大規模プロジェクトや安定しているプロジェクトのように、何を受け入れるかを慎重に決めなければいけない場合です。

//////////////////////////
If you have a more important project, you might want to use a two-phase merge cycle.
In this scenario, you have two long-running branches, `master` and `develop`, in which you determine that `master` is updated only when a very stable release is cut and all new code is integrated into the `develop` branch.
You regularly push both of these branches to the public repository.
Each time you have a new topic branch to merge in (<<merwf_c>>), you merge it into `develop` (<<merwf_d>>); then, when you tag a release, you fast-forward `master` to wherever the now-stable `develop` branch is (<<merwf_e>>).
//////////////////////////
より重要なプロジェクトの場合は、二段階のマージサイクルを使うこともあるでしょう。
ここでは、長期間運用するブランチが `master` と `develop` のふたつあるものとします。`master` が更新されるのは安定版がリリースされるときだけで、新しいコードはずべて `develop` ブランチに統合されるという流れです。
これらのブランチは、両方とも定期的に公開リポジトリにプッシュすることになります。
新しいトピックブランチをマージする準備ができたら (<<merwf_c>>)、それを `develop` にマージします (<<merwf_d>>)。そしてリリースタグを打つときに、`master` を現在の `develop` ブランチが指す位置に進めます (<<merwf_e>>)。

[[merwf_c]]
//////////////////////////
.Before a topic branch merge.
image::images/merging-workflows-3.png[Before a topic branch merge.]
//////////////////////////
.トピックブランチのマージ前
image::images/merging-workflows-3.png[トピックブランチのマージ前]

[[merwf_d]]
//////////////////////////
.After a topic branch merge.
image::images/merging-workflows-4.png[After a topic branch merge.]
//////////////////////////
.トピックブランチのマージ後
image::images/merging-workflows-4.png[トピックブランチのマージ後]

[[merwf_e]]
//////////////////////////
.After a project release.
image::images/merging-workflows-5.png[After a topic branch release.]
//////////////////////////
.プロジェクトのリリース後
image::images/merging-workflows-5.png[トピックブランチのリリース後]

//////////////////////////
This way, when people clone your project's repository, they can either check out master to build the latest stable version and keep up to date on that easily, or they can check out develop, which is the more cutting-edge stuff.
You can also continue this concept, having an integrate branch where all the work is merged together.
Then, when the codebase on that branch is stable and passes tests, you merge it into a develop branch; and when that has proven itself stable for a while, you fast-forward your master branch.
//////////////////////////
他の人があなたのプロジェクトをクローンするときには、master をチェックアウトすれば最新の安定版をビルドすることができ、その後の更新を追いかけるのも容易にできるようになります。一方 develop をチェックアウトすれば、さらに最先端の状態を取得することができます。
この考え方を推し進めると、統合用のブランチを用意してすべての作業をいったんそこにマージするようにもできます。
統合ブランチ上のコードが安定してテストを通過すれば、それを develop ブランチにマージします。そしてそれが安定していることが確認できたら master ブランチを先に進めるということになります。

//////////////////////////
===== Large-Merging Workflows
//////////////////////////
===== 大規模マージのワークフロー

(((workflows, "merging (large)")))
//////////////////////////
The Git project has four long-running branches: `master`, `next`, and `pu` (proposed updates) for new work, and `maint` for maintenance backports.
When new work is introduced by contributors, it's collected into topic branches in the maintainer's repository in a manner similar to what we've described (see <<merwf_f>>).
At this point, the topics are evaluated to determine whether they're safe and ready for consumption or whether they need more work.
If they're safe, they're merged into `next`, and that branch is pushed up so everyone can try the topics integrated together.
//////////////////////////
Git 開発プロジェクトには、常時稼働するブランチが四つあります。`master`、`next`、そして新しい作業用の `pu` (proposed updates) とメンテナンスバックポート用の `maint` です。
新しいコードを受け取ったメンテナは、まず自分のリポジトリのトピックブランチにそれを格納します。先ほど説明したのと同じ方式です ( <<merwf_f>> を参照ください)。
そしてその内容を検証し、安全に取り込める状態かさらなる作業が必要かを見極めます。
だいじょうぶだと判断したらそれを `next` にマージします。このブランチをプッシュすれば、すべてのメンバーがそれを試せるようになります。

[[merwf_f]]
//////////////////////////
.Managing a complex series of parallel contributed topic branches.
image::images/large-merges-1.png[Managing a complex series of parallel contributed topic branches.]
//////////////////////////
.複数のトピックブランチの並行管理
image::images/large-merges-1.png[複数のトピックブランチの並行管理]

//////////////////////////
If the topics still need work, they're merged into `pu` instead.
When it's determined that they're totally stable, the topics are re-merged into `master` and are then rebuilt from the topics that were in `next` but didn't yet graduate to `master`.
This means `master` almost always moves forward, `next` is rebased occasionally, and `pu` is rebased even more often:
//////////////////////////
さらに作業が必要なトピックについては、`pu` にマージします。
完全に安定していると判断されたトピックについては改めて `master` にマージされ、`next` にあるトピックのうちまだ `master` に入っていないものを再構築します。
つまり、`master` はほぼ常に前に進み、`next` は時々リベースされ、`pu` はそれ以上の頻度でリベースされることになります。

//////////////////////////
.Merging contributed topic branches into long-term integration branches.
image::images/large-merges-2.png[Merging contributed topic branches into long-term integration branches.]
//////////////////////////
.常時稼働する統合用ブランチへのトピックブランチのマージ
image::images/large-merges-2.png[常時稼働する統合用ブランチへのトピックブランチのマージ]

//////////////////////////
When a topic branch has finally been merged into `master`, it's removed from the repository.
The Git project also has a `maint` branch that is forked off from the last release to provide backported patches in case a maintenance release is required.
Thus, when you clone the Git repository, you have four branches that you can check out to evaluate the project in different stages of development, depending on how cutting edge you want to be or how you want to contribute; and the maintainer has a structured workflow to help them vet new contributions.
//////////////////////////
最終的に `master` にマージされたトピックブランチは、リポジトリから削除します。
Git 開発プロジェクトでは `maint` ブランチも管理しています。これは最新のリリースからフォークしたもので、メンテナンスリリースに必要なバックポート用のパッチを管理します。
つまり、Git のリポジトリをクローンするとあなたは四つのブランチをチェックアウトすることができるということです。これらのブランチはどれも異なる開発段階を表し、「どこまで最先端を追いかけたいか」「どのように Git プロジェクトに貢献したいか」によって使い分けることになります。メンテナ側では、新たな貢献を受け入れるためのワークフローが整っています。

[[_rebase_cherry_pick]]
//////////////////////////
===== Rebasing and Cherry Picking Workflows
//////////////////////////
===== リベースとチェリーピックのワークフロー

(((workflows, rebasing and cherry-picking)))
//////////////////////////
Other maintainers prefer to rebase or cherry-pick contributed work on top of their master branch, rather than merging it in, to keep a mostly linear history.
When you have work in a topic branch and have determined that you want to integrate it, you move to that branch and run the rebase command to rebuild the changes on top of your current master (or `develop`, and so on) branch.
If that works well, you can fast-forward your `master` branch, and you'll end up with a linear project history.
//////////////////////////
受け取った作業を master ブランチにマージするのではなく、リベースやチェリーピックを使って master ブランチの先端につなげていく方法を好むメンテナもいます。そのほうがほぼ直線的な歴史を保てるからです。
トピックブランチでの作業を終えて統合できる状態になったと判断したら、そのブランチで rebase コマンドを実行し、その変更を現在の master (あるいは `develop` などの) ブランチの先端につなげます。
うまくいけば、`master` ブランチをそのまま前に進めてることでプロジェクトの歴史を直線的に進めることができます。

(((git commands, cherry-pick)))
//////////////////////////
The other way to move introduced work from one branch to another is to cherry-pick it.
A cherry-pick in Git is like a rebase for a single commit.
It takes the patch that was introduced in a commit and tries to reapply it on the branch you're currently on.
This is useful if you have a number of commits on a topic branch and you want to integrate only one of them, or if you only have one commit on a topic branch and you'd prefer to cherry-pick it rather than run rebase.
For example, suppose you have a project that looks like this:
//////////////////////////
あるブランチの作業を別のブランチに移すための手段として、他にチェリーピック (つまみぐい) という方法があります。
Git におけるチェリーピックとは、コミット単位でのリベースのようなものです。
あるコミットによって変更された内容をパッチとして受け取り、それを現在のブランチに再適用します。
トピックブランチでいくつかコミットしたうちのひとつだけを統合したい場合、あるいはトピックブランチで一回だけコミットしたけれどそれをリベースではなくチェリーピックで取り込みたい場合などにこの方法を使用します。
以下のようなプロジェクトを例にとって考えましょう。

//////////////////////////
.Example history before a cherry-pick.
image::images/rebasing-1.png[Example history before a cherry-pick.]
//////////////////////////
.チェリーピック前の歴史
image::images/rebasing-1.png[チェリーピック前の歴史]

//////////////////////////
If you want to pull commit `e43a6` into your master branch, you can run
//////////////////////////
コミット `e43a6` を master ブランチに取り込むには、次のようにします。

[source,console]
-----
$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)
-----

//////////////////////////
This pulls the same change introduced in `e43a6`, but you get a new commit SHA-1 value, because the date applied is different.
Now your history looks like this:
//////////////////////////
これは `e43a6` と同じ内容の変更を施しますが、コミットの SHA-1 値は新しくなります。適用した日時が異なるからです。
これで、歴史は次のように変わりました。

//////////////////////////
.History after cherry-picking a commit on a topic branch.
image::images/rebasing-2.png[History after cherry-picking a commit on a topic branch.]
//////////////////////////
.トピックブランチのコミットをチェリーピックした後の歴史
image::images/rebasing-2.png[トピックブランチのコミットをチェリーピックした後の歴史]

//////////////////////////
Now you can remove your topic branch and drop the commits you didn't want to pull in.
//////////////////////////
あとは、このトピックブランチを削除すれば取り込みたくない変更を消してしまうことができます。

===== Rerere

(((git commands, rerere)))(((rerere)))
If you're doing lots of merging and rebasing, or you're maintaining a long-lived topic branch, Git has a feature called ``rerere'' that can help.

Rerere stands for ``reuse recorded resolution'' – it's a way of shortcutting manual conflict resolution.
When rerere is enabled, Git will keep a set of pre- and post-images from successful merges, and if it notices that there's a conflict that looks exactly like one you've already fixed, it'll just use the fix from last time, without bothering you with it.

This feature comes in two parts: a configuration setting and a command.
The configuration setting is `rerere.enabled`, and it's handy enough to put in your global config:

[source,console]
----
$ git config --global rerere.enabled true
----

Now, whenever you do a merge that resolves conflicts, the resolution will be recorded in the cache in case you need it in the future.

If you need to, you can interact with the rerere cache using the `git rerere` command.
When it's invoked alone, Git checks its database of resolutions and tries to find a match with any current merge conflicts and resolve them (although this is done automatically if `rerere.enabled` is set to `true`).
There are also subcommands to see what will be recorded, to erase specific resolution from the cache, and to clear the entire cache. We will cover rerere in more detail in <<_rerere>>.

[[_tagging_releases]]
//////////////////////////
==== Tagging Your Releases
//////////////////////////
==== リリース用のタグ付け

//////////////////////////
(((tags)))(((tags, signing)))
When you've decided to cut a release, you'll probably want to drop a tag so you can re-create that release at any point going forward.
You can create a new tag as discussed in <<_git_basics_chapter>>.
If you decide to sign the tag as the maintainer, the tagging may look something like this:
//////////////////////////
いよいよリリースする時がきました。おそらく、後からいつでもこのリリースを取得できるようにタグを打っておくことになるでしょう。
新しいタグを打つ方法は <<_git_basics_chapter>> で説明しました。
タグにメンテナの署名を入れておきたい場合は、このようにします。

[source,console]
-----
$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon <schacon@gmail.com>"
1024-bit DSA key, ID F721C45A, created 2009-02-09
-----

//////////////////////////
If you do sign your tags, you may have the problem of distributing the public PGP key used to sign your tags.
The maintainer of the Git project has solved this issue by including their public key as a blob in the repository and then adding a tag that points directly to that content.
To do this, you can figure out which key you want by running `gpg --list-keys`:
//////////////////////////
タグに署名した場合、署名に使用した PGP 鍵ペアの公開鍵をどのようにして配布するかが問題になるかもしれません。
Git 開発プロジェクトのメンテナ達がこの問題をどのように解決したかというと、自分たちの公開鍵を blob としてリポジトリに含め、それを直接指すタグを追加することにしました。
この方法を使うには、まずどの鍵を使うかを決めるために `gpg --list-keys` を実行します。

[source,console]
-----
$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon <schacon@gmail.com>
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]
-----

//////////////////////////
Then, you can directly import the key into the Git database by exporting it and piping that through `git hash-object`, which writes a new blob with those contents into Git and gives you back the SHA-1 of the blob:
//////////////////////////
鍵を直接 Git データベースにインポートするには、鍵をエクスポートしてそれをパイプで `git hash-object` に渡します。これは、鍵の中身を新しい blob として Git に書き込み、その blob の SHA-1 を返します。

[source,console]
-----
$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92
-----

//////////////////////////
Now that you have the contents of your key in Git, you can create a tag that points directly to it by specifying the new SHA-1 value that the `hash-object` command gave you:
//////////////////////////
鍵の中身を Git に取り込めたので、この鍵を直接指定するタグを作成できるようになりました。`hash-object` コマンドで知った SHA-1 値を指定すればいいのです。

[source,console]
-----
$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92
-----

//////////////////////////
If you run `git push --tags`, the `maintainer-pgp-pub` tag will be shared with everyone.
If anyone wants to verify a tag, they can directly import your PGP key by pulling the blob directly out of the database and importing it into GPG:
//////////////////////////
`git push --tags` を実行すると、`maintainer-pgp-pub` タグをみんなと共有できるようになります。誰かがタグを検証したい場合は、あなたの PGP 鍵が入った blob をデータベースから直接プルで取得し、それを PGP にインポートすればいいのです。

[source,console]
-----
$ git show maintainer-pgp-pub | gpg --import
-----

//////////////////////////
They can use that key to verify all your signed tags.
Also, if you include instructions in the tag message, running `git show <tag>` will let you give the end user more specific instructions about tag verification.
//////////////////////////
この鍵をインポートした人は、あなたが署名したすべてのタグを検証できるようになります。タグのメッセージに検証手順の説明を含めておけば、`git show <tag>` でエンドユーザー向けに詳しい検証手順を示すことができます。

[[_build_number]]
//////////////////////////
==== Generating a Build Number
//////////////////////////
==== ビルド番号の生成

(((build numbers)))(((git commands, describe)))
//////////////////////////
Because Git doesn't have monotonically increasing numbers like 'v123' or the equivalent to go with each commit, if you want to have a human-readable name to go with a commit, you can run `git describe` on that commit.
Git gives you the name of the nearest tag with the number of commits on top of that tag and a partial SHA-1 value of the commit you're describing:
//////////////////////////
Git では、コミットごとに 'v123' のような単調な番号を振っていくことはありません。もし特定のコミットに対して人間がわかりやすい名前がほしければ、そのコミットに対して `git describe` を実行します。
Git は、そのコミットに最も近いタグの名前とそのタグからのコミット数、そしてそのコミットの SHA-1 値の一部を使った名前を作成します。

[source,console]
-----
$ git describe master
v1.6.2-rc1-20-g8c5b85c
-----

//////////////////////////
This way, you can export a snapshot or build and name it something understandable to people.
In fact, if you build Git from source code cloned from the Git repository, `git --version` gives you something that looks like this.
If you're describing a commit that you have directly tagged, it gives you the tag name.
//////////////////////////
これで、スナップショットやビルドを公開するときにわかりやすい名前をつけられるようになります。
実際、Git そのもののソースコードを Git リポジトリからクローンしてビルドすると、`git --version` が返す結果はこの形式になります。
タグが打たれているコミットを直接指定した場合は、タグの名前が返されます。

//////////////////////////
The `git describe` command favors annotated tags (tags created with the `-a` or `-s` flag), so release tags should be created this way if you're using `git describe`, to ensure the commit is named properly when described.
You can also use this string as the target of a checkout or show command, although it relies on the abbreviated SHA-1 value at the end, so it may not be valid forever.
For instance, the Linux kernel recently jumped from 8 to 10 characters to ensure SHA-1 object uniqueness, so older `git describe` output names were invalidated.
//////////////////////////
`git describe` コマンドは注釈付きのタグ (`-a` あるいは `-s` フラグをつけて作成したタグ) を使います。したがって、`git describe` を使うならリリースタグは注釈付きのタグとしなければなりません。そうすれば、describe したときにコミットの名前を適切につけることができます。
この文字列を checkout コマンドや show コマンドでの対象の指定に使うこともできますが、これは末尾にある SHA-1 値の省略形に依存しているので将来にわたってずっと使えるとは限りません。
たとえば Linux カーネルは、最近 SHA-1 オブジェクトの一意性を確認するための文字数を 8 文字から 10 文字に変更しました。そのため、古い `git describe` の出力での名前はもはや使えません。

[[_preparing_release]]
//////////////////////////
==== Preparing a Release
//////////////////////////
==== リリースの準備

(((releasing)))(((git commands, archive)))
//////////////////////////
Now you want to release a build.
One of the things you'll want to do is create an archive of the latest snapshot of your code for those poor souls who don't use Git.
The command to do this is `git archive`:
//////////////////////////
実際にリリースするにあたって行うであろうことのひとつに、最新のスナップショットのアーカイブを作るという作業があります。
Git を使っていないというかわいそうな人たちにもコードを提供するために。
その際に使用するコマンドは `git archive` です。

[source,console]
-----
$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz
-----

//////////////////////////
If someone opens that tarball, they get the latest snapshot of your project under a project directory.
You can also create a zip archive in much the same way, but by passing the `--format=zip` option to `git archive`:
//////////////////////////
tarball を開けば、プロジェクトのディレクトリの下に最新のスナップショットが得られます。まったく同じ方法で zip アーカイブを作成することもできます。
この場合は `git archive` で `--format=zip` オプションを指定します。

[source,console]
-----
$ git archive master --prefix='project/' --format=zip > `git describe master`.zip
-----

//////////////////////////
You now have a nice tarball and a zip archive of your project release that you can upload to your website or e-mail to people.
//////////////////////////
これで、あなたのプロジェクトのリリース用にすてきな tarball と zip アーカイブができあがりました。これをウェブサイトにアップロードするなりメールで送ってあげるなりしましょう。

[[_the_shortlog]]
//////////////////////////
==== The Shortlog
//////////////////////////
==== 短いログ

(((git commands, shortlog)))
//////////////////////////
It's time to e-mail your mailing list of people who want to know what's happening in your project.
A nice way of quickly getting a sort of changelog of what has been added to your project since your last release or e-mail is to use the `git shortlog` command.
It summarizes all the commits in the range you give it; for example, the following gives you a summary of all the commits since your last release, if your last release was named v1.0.1:
//////////////////////////
そろそろメーリングリストにメールを送り、プロジェクトに何が起こったのかをみんなに知らせてあげましょう。
前回のリリースから何が変わったのかの変更履歴を手軽に取得するには `git shortlog` コマンドを使います。
これは、指定した範囲のすべてのコミットのまとめを出力します。たとえば、直近のリリースの名前が v1.0.1 だった場合は、次のようにすると前回のリリース以降のすべてのコミットの概要が得られます。

[source,console]
-----
$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2
-----

//////////////////////////
You get a clean summary of all the commits since v1.0.1, grouped by author, that you can e-mail to your list.
//////////////////////////
v1.0.1 以降のすべてのコミットの概要が、作者別にまとめて得られました。これをメーリングリストに投稿するといいでしょう。
